/*
    Minified by Jellevdg3's minifier at 12/May/2014 10:52:57.
*/
/**
 * Created by Jelle on 4/28/2014.
 */

Align = function(ratiox, ratioy)
{
    this.ratiox = ratiox;
    this.ratioy = ratioy;

    this.set();

    Align.aligns.push(this);
};

Align.aligns = [];

Align.screenW = 0;
Align.screenH = 0;

Align.width = 1920;
Align.height = 1080;

Align.ratiox = 0;
Align.ratioy = 0;

Align.setSS = function(w, h)
{
    Align.screenW = w;
    Align.screenH = h;

    Align.ratiox = Align.screenW / Align.width;
    Align.ratioy = Align.screenH / Align.height;

    Align.ratiorevx = Align.width / Align.screenW;
    Align.ratiorevy = Align.height / Align.screenH;

    for(var i = 0; i < Align.aligns.length; i++)
    {
        Align.aligns[i].set();
    }
};

Align.prototype.set = function()
{
    this.sw = this.x(Align.width);
    this.sh = this.y(Align.height);
};

Align.prototype.sx = function()
{
    return this.sw;
};

Align.prototype.sy = function()
{
    return this.sh;
};

Align.prototype.x = function(w)
{
    return parseInt(w * this.ratiox);
};

Align.prototype.y = function(h)
{
    return parseInt(h * this.ratioy);
};

Align.LEFT = new Align(0.0, 0.0);
Align.TOP = new Align(0.0, 0.0);
Align.CENTER = new Align(0.5, 0.5);
Align.RIGHT = new Align(1.0, 0.0);
Align.BOTTOM = new Align(0.0, 1.0);
/**
 * Created by Jelle on 4/27/2014.
 */

Button = function()
{
    this.texture = null;
    this.x = 0;
    this.y = 0;
    this.width = 100;
    this.height = 100;

    this.item = undefined;

    this.alignx = Align.LEFT;
    this.aligny = Align.TOP;
};

Button.prototype.setTexture = function(texture)
{
    this.texture = texture;
};

Button.prototype.setPosition = function(x, y)
{
    this.x = x;
    this.y = y;
};

Button.prototype.setSize = function(width, height)
{
    this.width = width;
    this.height = height;
};

Button.prototype.initialize = function()
{
    if(this.item == undefined)
    {
        console.error("Item is undefined.");
    }

    this.x -= parseInt(this.width / 2);
    this.y -= parseInt(this.height / 2);
};

Button.prototype.tick = function()
{
    if(this.item.itemHandler.windowHandler.isMouseDown())
    {
        var mousesdown = this.item.itemHandler.windowHandler.getMousesDown();
        for(var i = 0; i < mousesdown.length; i++)
        {
            if(mousesdown[i].ticksAlive == 1 && mousesdown[i].x >= this.alignx.sx() + this.x && mousesdown[i].y >= this.aligny.sy() + this.y && mousesdown[i].x < this.alignx.sx() + this.x + this.width && mousesdown[i].y < this.aligny.sy() + this.y + this.height)
            {
                this.onClick();
                break;
            }
        }
    }
};

Button.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.texture, this.alignx.sx() + this.x, this.aligny.sy() + this.y, this.width, this.height);
};

// events
Button.prototype.onClick = function(){};
/**
 * Created by Jelle on 5/6/2014.
 */

RotatableButton = function()
{
    this.texture = null;
    this.x = 0;
    this.y = 0;
    this.width = 100;
    this.height = 100;
    this.rotation = 0;

    this.item = undefined;

    this.alignx = Align.LEFT;
    this.aligny = Align.TOP;
};

RotatableButton.prototype.setTexture = function(texture)
{
    this.texture = texture;
};

RotatableButton.prototype.setPosition = function(x, y)
{
    this.x = x;
    this.y = y;
};

RotatableButton.prototype.setSize = function(width, height)
{
    this.width = width;
    this.height = height;
};

RotatableButton.prototype.initialize = function()
{
    if(this.item == undefined)
    {
        console.error("Item is undefined.");
    }

    this.x -= parseInt(this.width / 2);
    this.y -= parseInt(this.height / 2);
};

RotatableButton.prototype.tick = function()
{
    if(this.item.itemHandler.windowHandler.isMouseDown())
    {
        var mousesdown = this.item.itemHandler.windowHandler.getMousesDown();
        for(var i = 0; i < mousesdown.length; i++)
        {
            if(mousesdown[i].ticksAlive == 1 && mousesdown[i].x >= this.alignx.sx() + this.x && mousesdown[i].y >= this.aligny.sy() + this.y && mousesdown[i].x < this.alignx.sx() + this.x + this.width && mousesdown[i].y < this.aligny.sy() + this.y + this.height)
            {
                this.onClick();
                break;
            }
        }
    }
};

RotatableButton.prototype.draw = function(gfx)
{
    gfx.drawRotatedTexture(this.texture, this.alignx.sx() + this.x, this.aligny.sy() + this.y, this.width, this.height, this.rotation);
};

// events
RotatableButton.prototype.onClick = function(){};
/**
 * Created by Jelle on 4/25/2014.
 */

Canvas = function()
{
    this.canvas = document.createElement("canvas");
    document.body.appendChild(this.canvas);
    this.gfx = new GFX(this);

    this.rescale();
};

Canvas.prototype.rescale = function()
{
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.x = 0;
    this.y = 0;

    this.canvasWidth = this.width;
    this.canvasHeight = this.height;

    var arg_width = Arguments.get("w");
    var arg_height = Arguments.get("h");

    if(arg_width != undefined)
    {
        this.canvasWidth = parseInt(arg_width);
    }

    if(arg_height != undefined)
    {
        this.canvasHeight = parseInt(arg_height);
    }

    console.log("Canvas rescaling to " + this.canvasWidth + "x" + this.canvasHeight + ";");

    this.canvas.width = this.canvasWidth;
    this.canvas.height = this.canvasHeight;

    this.canvas.style.position = "absolute";
    this.canvas.style.width = window.innerWidth + "px";
    this.canvas.style.height = window.innerHeight + "px";
    this.canvas.style.left = 0 + "px";
    this.canvas.style.top = 0 + "px";
    this.canvas.style.imageRendering = "-webkit-optimize-contrast";

    // rotate
    this.rotated = false;
    this.gfx.gfx.translate(0, 0);
    this.gfx.gfx.rotate(0);
    this.gfx.gfx.scale(1, 1);

    if(this.height > this.width)
    {
        Align.setSS(this.height, this.width);

        this.rotated = true;

        this.gfx.gfx.scale(this.canvasWidth / Align.height, this.canvasHeight / Align.width);
        this.gfx.gfx.translate(Align.height, 0);
        this.gfx.gfx.rotate(90 * Math.PI / 180);
    }
    else
    {
        Align.setSS(this.width, this.height);
        this.gfx.gfx.rotate(0);
        this.gfx.gfx.scale(this.canvasWidth / Align.width, this.canvasHeight / Align.height);
    }
};
/**
 * Created by Jelle on 4/25/2014.
 */

GFX = function(canvas)
{
    this.canvas = canvas;
    this.gfx = this.canvas.canvas.getContext("2d");

    this.gfx.imageSmoothingEnabled = false;
    this.gfx.mozImageSmoothingEnabled = false;
    this.gfx.webkitImageSmoothingEnabled = false;

    this.gfx.save();
};

GFX.prototype.clear = function(style)
{
    this.gfx.fillStyle = style;
    this.gfx.fillRect(0, 0, Align.width, Align.height);
};

GFX.prototype.drawLine = function(x, y, w, h, strokeStyle, lineWidth)
{
    this.gfx.lineWidth = lineWidth;
    this.gfx.strokeStyle = strokeStyle;
    this.gfx.beginPath();
    this.gfx.moveTo(x, y);
    this.gfx.lineTo(x + w, y + h);
    this.gfx.stroke();
};

GFX.prototype.drawCurve = function(x1, y1, x2, y2, x3, y3, strokeStyle, lineWidth)
{
    this.gfx.lineWidth = lineWidth;
    this.gfx.strokeStyle = strokeStyle;
    this.gfx.beginPath();
	this.gfx.quadraticCurveTo(x1, y1, x2, y2);
	this.gfx.quadraticCurveTo(x2, y2, x3, y3);
    this.gfx.stroke();
};

GFX.prototype.fillCircle = function(x, y, radius, fillStyle)
{
    this.gfx.fillStyle = fillStyle;
    this.gfx.beginPath();
	this.gfx.arc(x, y, radius, 0, 2 * Math.PI);
    this.gfx.fill();
};

GFX.prototype.drawPath = function(path, len, strokeStyle, lineWidth)
{
    this.gfx.lineWidth = lineWidth;
    this.gfx.strokeStyle = strokeStyle;

    this.gfx.beginPath();

    if(path.length > 1)
    {
        this.gfx.moveTo(path[0], path[1]);

        for(var i = 1; i < len; i++)
        {
            this.gfx.lineTo(path[0 + (i * 2)], path[1 + (i * 2)]);
        }
    }

    this.gfx.stroke();
};

GFX.prototype.drawRect = function(x, y, w, h, strokeStyle, lineWidth)
{
    this.gfx.lineWidth = lineWidth;
    this.gfx.strokeStyle = strokeStyle;
    this.gfx.strokeRect(x, y, w, h);
};

GFX.prototype.fillRect = function(x, y, w, h, fillStyle)
{
    this.gfx.fillStyle = fillStyle;
    this.gfx.fillRect(x, y, w, h);
};

GFX.prototype.drawString = function(text, x, y, fillstyle, font)
{
    this.gfx.fillStyle = fillstyle;
    this.gfx.font = font;
    this.gfx.fillText(text, x, (y + 6));
};

GFX.prototype.drawCenteredString = function(text, x, y, fillstyle, font)
{
    var metrics = this.gfx.measureText(text);
    this.drawString(text, (x - (metrics.width / 2)), y, fillstyle, font);
};

GFX.prototype.drawTexture = function(texture, x, y, width, height)
{
    this.gfx.drawImage(texture, x, y, width, height);
};

GFX.prototype.drawRotatedTexture = function(texture, x, y, width, height, rotation)
{
    this.gfx.save();

    this.gfx.translate(x + (width / 2), y + (height / 2));

    this.gfx.rotate(rotation * (Math.PI / 180));

    this.gfx.drawImage(texture, -(width / 2), -(height / 2), width, height);

    this.gfx.restore();
};
/**
 * Created by Jelle on 5/8/2014.
 */

KeyEvent = function()
{
    this.keyCode = 0;
    this.ticksAlive = 0;
    this.isDown = false;
    this.remove = false;
};

KeyEvent.prototype.tick = function()
{
    console.log("Key down: " + this.keyCode);
};
/**
 * Created by Jelle on 5/5/2014.
 */

MouseEvent = function()
{
    this.x = 0;
    this.y = 0;
    this.newX = 0;
    this.newY = 0;
    this.lastX = 0;
    this.lastY = 0;
    this.ticksAlive = 0;
    this.remove = false;
    this.isMouse = false;
    this.isTouch = false;
};

MouseEvent.prototype.tick = function()
{
    this.ticksAlive++;

	this.beforeLastX = this.lastX;
	this.beforeLastY = this.lastY;
	
    this.lastX = this.x;
    this.lastY = this.y;

    this.x = this.newX;
    this.y = this.newY;
};
/**
 * Created by Jelle on 4/25/2014.
 */

WindowKeyboardListener = function()
{
    this.keys = [];
    for(var i = 0; i < 256; i++)
    {
        var keyEvent = new KeyEvent();
        keyEvent.keyCode = i;
        this.keys.push(keyEvent);
    }

    this.keysDown = [];

    window.onkeydown = new EventHandler(this, this.onKeyDown);
    window.onkeyup = new EventHandler(this, this.onKeyUp);
};

WindowKeyboardListener.prototype.tick = function()
{
    for(var i = 0; i < this.keysDown.length; i++)
    {
        this.keysDown[i].tick();

        if(this.keysDown[i].remove == true)
        {
            this.keysDown[i].remove = false;
            this.keysDown[i].isDown = false;
            this.keysDown[i].ticksAlive = 0;

            this.keysDown.splice(i, 1);
            i--;
        }
    }
};

// events
WindowKeyboardListener.prototype.onKeyDown = function(ev)
{
    ev.preventDefault();

    var keyCode = ev.keyCode;
    var keyEvent = this.keys[keyCode];
    this.keysDown.push(keyEvent);

    keyEvent.isDown = true;
};

WindowKeyboardListener.prototype.onKeyUp = function(ev)
{
    ev.preventDefault();

    var keyCode = ev.keyCode;
    var keyEvent = this.keys[keyCode];
    keyEvent.remove = true;
};
/**
 * Created by Jelle on 4/25/2014.
 */

WindowMouseListener = function()
{
    this.mousedown = [];
    this.touchIdToMouseEvent = [];
    this.mouseButtonToMouseEvent = [];

    this.isMouseDown = false;

    // mouse down
    window.onmousedown = new EventHandler(this, this.onMouseDown);
    window.onmousemove = new EventHandler(this, this.onMouseMove);
    window.onmouseup = new EventHandler(this, this.onMouseUp);

    window.ontouchstart = new EventHandler(this, this.onTouchDown);
    window.ontouchmove = new EventHandler(this, this.onTouchMove);
    window.ontouchend = new EventHandler(this, this.onTouchUp);
    window.ontouchcancel = new EventHandler(this, this.onTouchUp);

    window.oncontextmenu = function(){return false;};
};

WindowMouseListener.prototype.tick = function()
{
    for(var i = 0; i < this.mousedown.length; i++)
    {
        this.mousedown[i].tick();
        if(this.mousedown[i].remove == true)
        {
            if(this.mousedown[i].isMouse == true)
            {
                this.mouseButtonToMouseEvent[this.mousedown[i].id] = null;
            }

            if(this.mousedown[i].isTouch == true)
            {
                this.touchIdToMouseEvent[this.mousedown[i].id] = null;
            }
            this.mousedown.splice(i, 1);
            i--;
        }
    }

    this.isMouseDown = this.mousedown.length != 0;
};

WindowMouseListener.prototype.setMousePosition = function(mouseEvent, rx, ry)
{
    if(this.windowHandler.canvas.rotated == true)
    {
        mouseEvent.newY = Align.height - ((rx - this.windowHandler.canvas.x) * Align.ratiorevy);
        mouseEvent.newX = ((ry - this.windowHandler.canvas.y) * Align.ratiorevx);
    }
    else
    {
        mouseEvent.newX = ((rx - this.windowHandler.canvas.x) * Align.ratiorevx);
        mouseEvent.newY = ((ry - this.windowHandler.canvas.y) * Align.ratiorevy);
    }
};

// events
WindowMouseListener.prototype.onMouseDown = function(ev)
{
    ev.preventDefault();

    var id = parseInt(ev.button);

    var mouseEvent = new MouseEvent();

    mouseEvent.isMouse = true;

    mouseEvent.id = id;

    this.setMousePosition(mouseEvent, ev.pageX, ev.pageY);

    mouseEvent.lastX = mouseEvent.newX;
    mouseEvent.lastY = mouseEvent.newY;
    mouseEvent.x = mouseEvent.newX;
    mouseEvent.y = mouseEvent.newY;

    this.mouseButtonToMouseEvent[id] = mouseEvent;

    this.mousedown.push(mouseEvent);
};

WindowMouseListener.prototype.onMouseMove = function(ev)
{
    ev.preventDefault();

    var id = parseInt(ev.button);
    var mouseEvent = this.mouseButtonToMouseEvent[id];

    if(mouseEvent != undefined)
    {
        this.setMousePosition(mouseEvent, ev.pageX, ev.pageY);
    }
};

WindowMouseListener.prototype.onMouseUp = function(ev)
{
    ev.preventDefault();

    var id = parseInt(ev.button);
    var mouseEvent = this.mouseButtonToMouseEvent[id];

    mouseEvent.remove = true;
};

WindowMouseListener.prototype.onTouchDown = function(ev)
{
    ev.preventDefault();

    for(var i = 0; i < ev.changedTouches.length; i++)
    {
        var touch = ev.changedTouches[i];
        var id = parseInt(touch.identifier);

        var mouseEvent = new MouseEvent();

        mouseEvent.isTouch = true;

        mouseEvent.id = id;

        this.setMousePosition(mouseEvent, touch.pageX, touch.pageY);

        mouseEvent.lastX = mouseEvent.newX;
        mouseEvent.lastY = mouseEvent.newY;
        mouseEvent.x = mouseEvent.newX;
        mouseEvent.y = mouseEvent.newY;

        this.touchIdToMouseEvent[id] = mouseEvent;

        this.mousedown.push(mouseEvent);
    }
};

WindowMouseListener.prototype.onTouchMove = function(ev)
{
    ev.preventDefault();

    for(var i = 0; i < ev.changedTouches.length; i++)
    {
        var touch = ev.changedTouches[i];
        var id = parseInt(touch.identifier);
        var mouseEvent = this.touchIdToMouseEvent[id];

        this.setMousePosition(mouseEvent, touch.pageX, touch.pageY);
    }
};

WindowMouseListener.prototype.onTouchUp = function(ev)
{
    ev.preventDefault();

    for(var i = 0; i < ev.changedTouches.length; i++)
    {
        var touch = ev.changedTouches[i];
        var id = parseInt(touch.identifier);
        var mouseEvent = this.touchIdToMouseEvent[id];
        mouseEvent.remove = true;
    }
};
/**
 * Created by Jelle on 4/25/2014.
 */

SFX = function(){};

SFX.volume = 1.0;

SFX.setVolume = function(volume)
{
    SFX.volume = volume;
    if(SFX.backgroundSound != undefined)
    {
        SFX.backgroundSound.volume = volume;
    }
};

SFX.backgroundSound = undefined;

SFX.setBackgroundSound = function(src)
{
    SFX.stopBackgroundSound();

    var audio = new Audio();

    audio.addEventListener("canplay", function()
    {
        audio.loop = true;

        console.log("Play BackgroundSound " + src + ".");

        audio.addEventListener("ended", function()
        {
            console.log("Ended BackgroundSound " + src + ".");
            audio.currentTime = 0;
            audio.play();
            audio.loop = true;
        }, false);

        audio.play();
        audio.loop = true;
    }, false);

    audio.src = src;
    audio.load();

    SFX.backgroundSound = audio;
};

SFX.stopBackgroundSound = function()
{
    if(SFX.backgroundSound != undefined)
    {
        SFX.backgroundSound.stop();
        SFX.backgroundSound.pause();
        SFX.backgroundSound.currentTime = 0;
        SFX.backgroundSound.src = "";

        SFX.backgroundSound = undefined;
    }
};

SFX.playSound = function(src)
{
    var audio = new Audio();

    audio.addEventListener("canplay", function()
    {
        audio.play();
    });

    audio.src = src;
    audio.load();
};
/**
 * Created by Jelle on 4/25/2014.
 */

Arguments = function(){};

Arguments.args = [];

Arguments.add = function(key, value)
{
    Arguments.args[key] = value;
};

Arguments.initialize = function()
{
    var location = window.location.href.toString();

    if(location.indexOf("?") != -1)
    {
        var arguments = location.substr(location.indexOf("?") + 1).split("&");

        for(var i = 0; i < arguments.length; i++)
        {
            var data = arguments[i].split("=");

            if(data.length == 2)
            {
                var key = data[0];
                var value = data[1];
                if(key != undefined && value != undefined)
                {
                    Arguments.add(key, value);
                }
            }
        }
    }
};

Arguments.get = function(key)
{
    return Arguments.args[key];
};
/**
 * Created by Jelle on 4/26/2014.
 */

EventHandler = function(object, executeFunction)
{
    this.object = object;
    this.executeFunction = executeFunction;

    var instance = this;
    this.execute = function(args)
    {
        instance.executeFunction.call(instance.object, args);
    };
	
	return this.execute;
};
/**
 * Created by Jelle on 4/26/2014.
 */

ItemHandler = function()
{
    this.curItem = null;
    this.gotoItem = null;

    this.loadedItems = [];
};

ItemHandler.prototype.setGotoItem = function(item)
{
    this.gotoItem = item;
};

ItemHandler.prototype.tick = function()
{
    if(this.gotoItem != null)
    {
        if(this.curItem != null)
        {
            this.curItem.deActivate();
        }

        var found = null;
        for(var i = 0; i < this.loadedItems.length; i++)
        {
            if(this.loadedItems[i].constructor == this.gotoItem)
            {
                found = this.loadedItems[i];
                break;
            }
        }

        if(found == undefined)
        {
            this.curItem = new this.gotoItem();
            this.loadedItems.push(this.curItem);
        }
        else
        {
            this.curItem = found;
        }

        this.gotoItem = null;

        if(!this.curItem.hasInitialized)
        {
            this.curItem.itemHandler = this;
            this.curItem.hasInitialized = true;
            this.curItem.initialize();
        }

        this.curItem.activate();
    }

    this.curItem.tick();
};

ItemHandler.prototype.draw = function(gfx)
{
    this.curItem.draw(gfx);
};
/**
 * Created by Jelle on 4/25/2014.
 */

Loader = function(fileComponents)
{
    this.completeEventHandler = new EventHandler(this, this.loadComplete);

    this.fileComponents = fileComponents;
    this.index = 0;
    this.done = false;
};

Loader.prototype.start = function()
{
    if(this.hasNext() == true)
    {
        this.loadNext();
    }
    else
    {
        this.done = true;
    }
};

Loader.prototype.stringEndsWidth = function(text, suffix)
{
    return text.indexOf(suffix, text.length - suffix.length) !== -1;
};

Loader.prototype.hasNext = function()
{
    return this.index < this.fileComponents.length;
};

Loader.prototype.loadImage = function(path)
{
    console.log("Image path: " + path);
    var obj = new Image();
    obj.onload = this.completeEventHandler;
    obj.onerror = this.completeEventHandler;
    obj.src = path;
    return obj;
};

Loader.prototype.loadNext = function()
{
    if(this.stringEndsWidth(this.fileComponents[this.index].path, ".jpg"))
    {
        this.fileComponents[this.index].obj = this.loadImage(this.fileComponents[this.index].path);
    }

    if(this.stringEndsWidth(this.fileComponents[this.index].path, ".png"))
    {
        this.fileComponents[this.index].obj = this.loadImage(this.fileComponents[this.index].path);
    }
};

Loader.prototype.loadComplete = function()
{
    this.index += 1;

    if(this.hasNext() == true)
    {
        this.loadNext();
    }
    else
    {
        this.done = true;
    }
};
/**
 * Created by Jelle on 4/25/2014.
 */

Ticker = function()
{
    this.tickEventHandler = new EventHandler(this, this.tick);

    this.fps = 60;

    this.curTime = 0;
    this.lastTickTime = 0;
    this.curFPSCount = 0;
    this.lastFPSCountTime = 0;
    this.curFPS = 0;
    this.lastSleep = 0;
    this.restSleep = 0;

    this.handler = function(){};
    this.handler.tick = function(){};
};

Ticker.prototype.start = function()
{
    this.curTime = this.getCurTime();
    this.lastTickTime = this.curTime;
    this.lastFPSCountTime = this.curTime;
    setTimeout(this.tickEventHandler, 1);
};

Ticker.prototype.getCurTime = function()
{
    return Date.now();
};

Ticker.prototype.tick = function()
{
    // execute
    this.handler.tick();

    // calculate
    this.lastTickTime = this.curTime + this.lastSleep;
    this.curTime = this.getCurTime();

    if(this.curTime - this.lastFPSCountTime >= 1000)
    {
        this.lastFPSCountTime = this.curTime;
        this.curFPS = this.curFPSCount;
        console.log("FPS: " + this.curFPS);
        this.curFPSCount = 0;
    }

    this.curFPSCount++;

    var delta = this.curTime - this.lastTickTime;
    var sleep = (1000.0 / this.fps) - delta + this.restSleep;
    this.restSleep = sleep % 1;

    // sleep
    if(sleep >= 1)
    {
        sleep = parseInt(sleep);
        this.lastSleep = sleep;
        setTimeout(this.tickEventHandler, sleep);
    }
    else
    {
        this.lastSleep = 1;
        setTimeout(this.tickEventHandler, 1);
    }
};
/**
 * Created by Jelle on 4/25/2014.
 */
/**
 * Created by Jelle on 4/26/2014.
 */

WindowHandler = function()
{
    // prepare body
    document.body.style.overflow = "hidden";

    // add components
    this.canvas = new Canvas();
    this.gfx = this.canvas.gfx;
    this.keyboardListener = new WindowKeyboardListener();
    this.mouseListener = new WindowMouseListener();

    this.keyboardListener.windowHandler = this;
    this.mouseListener.windowHandler = this;

    this.ticker = new Ticker();
    this.itemHandler = new ItemHandler();
    this.itemHandler.windowHandler = this;

    this.ticker.handler = this;
    this.itemHandler.setGotoItem(ItemInitialize);

    // events
    window.onfocus = function(){};
    window.onblur = function(){};

    this.ticker.start();
};

WindowHandler.prototype.isMouseDown = function()
{
    return this.mouseListener.isMouseDown;
};

WindowHandler.prototype.getMousesDown = function()
{
    return this.mouseListener.mousedown;
};

WindowHandler.prototype.tick = function()
{
    // check if should rescale
    if(window.innerWidth != this.canvas.width || window.innerHeight != this.canvas.height)
    {
        this.canvas.rescale();
    }

    this.mouseListener.tick();
    this.keyboardListener.tick();

    this.itemHandler.tick();
    this.itemHandler.draw(this.gfx);
};

// events

/**
 * Created by Jelle on 5/7/2014.
 */

CollisionBox = function(x, y, width, height)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
};

CollisionBox.prototype.isCollidingWith = function(box)
{
    var tx1 = this.container.owner.x + this.x;
    var ty1 = this.container.owner.y + this.y;
    var tx2 = tx1 + this.width;
    var ty2 = ty1 + this.height;

    var cx1 = box.container.owner.x + box.x;
    var cy1 = box.container.owner.y + box.y;
    var cx2 = cx1 + box.width;
    var cy2 = cy1 + box.height;

    return CollisionUtil.checkCollision(tx1, ty1, tx2, ty2, cx1, cy1, cx2, cy2);
};

CollisionBox.prototype.draw = function(gfx)
{
    //gfx.fillRect(this.container.owner.x + this.x, this.container.owner.y + this.y, this.width, this.height, "#F00");
    //gfx.drawRect(this.container.owner.x + this.x, this.container.owner.y + this.y, this.width, this.height, "#000", 1);
};
/**
 * Created by Jelle on 5/7/2014.
 */

CollisionContainer = function()
{
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;

    this.boxes = [];

    this.isColliding = false;

    this.collidingWith = [];
};

CollisionContainer.prototype.addBox = function(x, y, width, height)
{
    var box = new CollisionBox(x, y, width, height);
    box.container = this;
    this.boxes.push(box);
};

CollisionContainer.prototype.initialize = function()
{
    var px1 = undefined;
    var py1 = undefined;
    var px2 = undefined;
    var py2 = undefined;

    for(var i = 0; i < this.boxes.length; i++)
    {
        var box = this.boxes[i];
        var cx1 = box.x;
        var cy1 = box.y;
        var cx2 = box.x + box.width;
        var cy2 = box.y + box.height;

        if(cx1 < px1 || px1 == undefined)
            px1 = cx1;
        if(cy1 < py1 || py1 == undefined)
            py1 = cy1;
        if(cx2 > px2 || px2 == undefined)
            px2 = cx2;
        if(cy2 > py2 || py2 == undefined)
            py2 = cy2;
    }

    if(px1 != undefined){this.x = px1;}else{this.x = 0;}
    if(py1 != undefined){this.y = py1;}else{this.y = 0;}
    if(px2 != undefined){this.width = px2 - px1;}else{this.width = 0;}
    if(py2 != undefined){this.height = py2 - py1;}else{this.height = 0;}
};

CollisionContainer.prototype.isCollidingWith = function(checkContainer)
{
    var tx1 = this.owner.x + this.x;
    var ty1 = this.owner.y + this.y;
    var tx2 = tx1 + this.width;
    var ty2 = ty1 + this.height;

    var cx1 = checkContainer.owner.x + checkContainer.x;
    var cy1 = checkContainer.owner.y + checkContainer.y;
    var cx2 = cx1 + checkContainer.width;
    var cy2 = cy1 + checkContainer.height;

    return CollisionUtil.checkCollision(tx1, ty1, tx2, ty2, cx1, cy1, cx2, cy2);
};

CollisionContainer.prototype.tick = function(obstacles)
{
    for(var i = 0; i < obstacles.length; i++)
    {
        if(obstacles[i].collisionContainer.isCollidingWith(this))
        {
            if(obstacles[i].collisionContainer.boxes.length == 1)
            {
                obstacles[i].onPlayerCollision(this.owner);
            }
            else
            {
                var boxes = obstacles[i].collisionContainer.boxes;
                for(var j = 0; j < boxes.length; j++)
                {
                    if(boxes[j].isCollidingWith(this.boxes[0]))
                    {
                        obstacles[i].onPlayerCollision(this.owner);
                        break;
                    }
                }
            }
        }
    }
};

CollisionContainer.prototype.draw = function(gfx)
{
    if(this.boxes.length > 0)
    {
        for(var i = 0; i < this.boxes.length; i++)
        {
            //this.boxes[i].draw(gfx);
        }
    }

    if(this.isColliding == true)
    {
        this.isColliding = false;
        //gfx.drawRect(this.owner.x + this.x, this.owner.y + this.y, this.width, this.height, "#00F", 2);
    }
    else
    {
        //gfx.drawRect(this.owner.x + this.x, this.owner.y + this.y, this.width, this.height, "#FF0", 2);
    }
};
/**
 * Created by Jelle on 5/9/2014.
 */

CollisionUtil = function(){};

CollisionUtil.checkCollision = function(tx1, ty1, tx2, ty2, cx1, cy1, cx2, cy2)
{
    // left
    if (tx2 > cx1 && tx1 < cx1)
    {
        if ((ty1 < cy2 && ty2 > cy1) || (ty2 > cy1 && ty1 < cy2))
        {
            return true;
        }
    }

    // up
    if (ty1 < cy2 && ty2 > cy2)
    {
        if ((tx1 < cx2 && tx2 > cx1) || (tx2 > cx1 && tx1 < cx2))
        {
            return true;
        }
    }

    // right
    if (tx1 < cx2 && tx2 > cx2)
    {
        if ((ty1 < cy2 && ty2 > cy1) || (ty2 > cy1 && ty1 < cy2))
        {
            return true;
        }
    }

    // down
    if (ty2 > cy1 && ty1 < cy1)
    {
        if ((tx1 < cx2 && tx2 > cx1) || (tx2 > cx1 && tx1 < cx2))
        {
            return true;
        }
    }

    return false;
};
/**
 * Created by Jelle on 5/7/2014.
 */

Obstacle = function()
{
    this.remove = false;

    this.texture = Files.PIC_GAME_OBJECT_OBSTACLEWALLNORMAL.obj;

    this.width = this.texture.width;
    this.height = this.texture.height;

    this.x = Align.width;
    this.y = (Align.height / 2) - (this.height + 1);

    this.collisionContainer = new CollisionContainer();
    this.collisionContainer.addBox(0, 0, this.width, this.height);

    this.collisionContainer.owner = this;
    this.collisionContainer.initialize();
};

Obstacle.prototype.onPlayerCollision = function(player)
{
    this.collisionContainer.isColliding = true;
    player.onCollision();
};

Obstacle.prototype.tick = function()
{
    this.x -= 10;
    if(this.x < 0 - this.width)
    {
        this.remove = true;
    }
};

Obstacle.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.texture, this.x, this.y, this.width, this.height);

    this.collisionContainer.draw(gfx, this.x, this.y);
};
/**
 * Created by Jelle on 5/7/2014.
 */

ObjectHandler = function(world)
{
    this.world = world;

    // obstacles
    this.obstacleSpawner = new ObstacleSpawner();
    this.obstacleSpawner.objectHandler = this;
    this.obstacles = [];

    // player
    this.player = new Player(this.world.dir);
    this.player.objectHandler = this;
};

ObjectHandler.prototype.initialize = function()
{
    this.obstacleSpawner.initialize();
    this.player.otherPlayer = this.world.otherWorld.objectHandler.player;
};

ObjectHandler.prototype.addObstacle = function(obj)
{
    this.obstacles.push(obj);
};

ObjectHandler.prototype.tick = function()
{
    this.obstacleSpawner.tick();

    for(var i = 0; i < this.obstacles.length; i++)
    {
        this.obstacles[i].tick();
        if(this.obstacles[i].remove == true)
        {
            this.obstacles.splice(i, 1);
            i -= 1;
        }
    }

    this.player.tick();
};

ObjectHandler.prototype.draw = function(gfx)
{
    for(var i = 0; i < this.obstacles.length; i++)
    {
        this.obstacles[i].draw(gfx);
    }

    this.player.draw(gfx);
};
/**
 * Created by Jelle on 5/7/2014.
 */

ObstacleSpawner = function()
{
    this.curTick = 300;
};

ObstacleSpawner.prototype.initialize = function()
{
    this.sharedSpawnOptions = this.objectHandler.world.gameHandler.sharedSpawnOptions;
};

ObstacleSpawner.prototype.spawn = function()
{
    this.curTick = 0;
    var obstacle = new Obstacle(this.objectHandler.world.dir);
    this.objectHandler.addObstacle(obstacle);
};

ObstacleSpawner.prototype.tick = function()
{
    this.curTick++;

    if(this.curTick > 300)
    {
        this.spawn();
    }
};
/**
 * Created by Jelle on 5/6/2014.
 */

Player = function()
{
    this.texture = Files.PIC_GAME_OBJECT_PLAYER.obj;

    this.width = this.texture.width;
    this.height = this.texture.height;

    this.collisionContainer = new CollisionContainer();
    this.collisionContainer.addBox(0, 0, this.width, this.height);

    this.collisionContainer.owner = this;
    this.collisionContainer.initialize();

    this.hasCollided = false;

    this.x = (Align.width / 2) - (this.width / 2);
    this.y = (Align.height / 2) - ((this.collisionContainer.height + 1) + this.collisionContainer.y);
    this.groundy = this.y;

    this.gravity = 0.8;
    this.speedy = 0;
    this.shouldStomp = false;
    this.hasJumped = false;
};

Player.prototype.tryJump = function()
{
    if(this.hasCollided == false)
    {
        if(this.hasJumped == false)
        {
            this.speedy = -20;
            this.hasJumped = true;
        }
        else
        {
            this.speedy = 50;
            this.shouldStomp = true;
        }
    }
};

Player.prototype.tryStomp = function()
{
    if(this.hasCollided == false && this.y == this.groundy)
    {
        this.speedy = -20;
    }
};

Player.prototype.onCollision = function()
{
    this.collisionContainer.isColliding = true;
    this.hasCollided = true;
    this.shouldStomp = false;
};

Player.prototype.tick = function()
{
    this.speedy += this.gravity;
    this.y += this.speedy;

    if(this.y >= this.groundy)
    {
        this.y = this.groundy;
        this.hasJumped = false;
        if(this.shouldStomp)
        {
            this.shouldStomp = false;
            this.otherPlayer.tryStomp();
        }
    }

    this.collisionContainer.tick(this.objectHandler.obstacles);
    if(this.hasCollided == true)
    {
        this.x -= 10;
        if(this.x < 0 - this.width)
        {
            this.x = (Align.width / 2) - (this.width / 2);
            this.hasCollided = false;
        }
    }
};

Player.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.texture, this.x, this.y, this.width, this.height);

    this.collisionContainer.draw(gfx);
};
/**
 * Created by Jelle on 5/9/2014.
 */

SharedSpawnOptions = function()
{

};
/**
 * Created by Jelle on 5/7/2014.
 */

World = function(dir)
{
    this.dir = dir;

    this.backgroudTexture = Files.PIC_GAME__BACKGROUND.obj;

    this.buttons = [];

    var button = undefined;

    // Jump button
    button = new RotatableButton();
    button.alignx = Align.LEFT;
    button.aligny = Align.TOP;
    button.setTexture(Files.PIC_GAME_BUTTON_JUMP.obj);
    button.setSize(Files.PIC_GAME_BUTTON_JUMP.obj.width, Files.PIC_GAME_BUTTON_JUMP.obj.height);

    var screenPosX = -(Align.width / 2) * (dir - 1);
    var screenPosY = -(Align.height / 2) * (dir - 1);

    var objPosX = (button.width / 2) * (dir);
    var objPosY = (button.height / 2) * (dir);

    button.setPosition(screenPosX + objPosX, screenPosY + objPosY);

    button.rotation = (dir + 1) * 90;
    button.world = this;
    button.onClick = function(){this.world.otherWorld.objectHandler.player.tryJump();};
    this.buttons.push(button);

    // Back button
    button = new RotatableButton();
    button.alignx = Align.LEFT;
    button.aligny = Align.TOP;
    button.setTexture(Files.PIC_GAME_BUTTON_BACK.obj);
    button.setSize(Files.PIC_GAME_BUTTON_BACK.obj.width, Files.PIC_GAME_BUTTON_BACK.obj.height);

    var screenPosX = (Align.width / 2) * (dir + 1);
    var screenPosY = -(Align.height / 2) * (dir - 1);

    var objPosX = -(button.width / 2) * (dir);
    var objPosY = (button.height / 2) * (dir);

    button.setPosition(screenPosX + objPosX, screenPosY + objPosY);

    button.rotation = (dir + 1) * 90;
    button.world = this;
    button.onClick = function(){this.world.gameHandler.item.itemHandler.setGotoItem(ItemMainMenu)};
    this.buttons.push(button);

    this.objectHandler = new ObjectHandler(this);
};

World.prototype.initialize = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].item = this.gameHandler.item;
        this.buttons[i].initialize();
    }

    this.objectHandler.initialize();
};

World.prototype.tick = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].tick();
    }

    this.objectHandler.tick();
};

World.prototype.draw = function(gfx)
{
    // prepare draw
    gfx.gfx.save();
    gfx.gfx.scale(1, this.dir);
    gfx.gfx.translate(0, (Align.height / 2) * (this.dir - 1));

    gfx.drawTexture(this.backgroudTexture, 0, 0, Align.width, Align.height / 2);
    this.objectHandler.draw(gfx);
    gfx.gfx.restore();

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].draw(gfx);
    }
};
JumpState = function(pWorld)
{
    this.world = pWorld;
    this.objectHandler = this.world.objectHandler;
    this.innerState = 0;
    this.done = false;
};

JumpState.prototype.nextInnerState = function()
{
    this.innerState++;
};

JumpState.prototype.start = function()
{
    this.spawnBlock();
    this.innerState++;
};

JumpState.prototype.handleJump = function()
{
    if(this.innerState >= 1){
        if(this.innerState == 1)
        {
            this.world.worldPaused = false;
            this.nextInnerState();
        }
        return true;
    } else {
        return false;
    }
}

JumpState.prototype.spawnBlock = function()
{
    this.world.currentObstacle = new Obstacle(this.world.dir);
    this.world.objectHandler.addObstacle(this.world.currentObstacle);
};

JumpState.prototype.reset = function()
{
    this.innerState = 0;
    this.done = false;
    this.start();
};

JumpState.prototype.tick = function()
{
    var distToPlayer = this.world.currentObatacleFromPlayer();

    if(this.innerState == 1)
    {
        if(distToPlayer > 0 && distToPlayer < 200)
        {
            this.world.worldPaused = true;
            // After the jump the innerState will be incremented to 2
        }
    }
    else if(this.innerState == 2)
    {
        if(distToPlayer < -200)
        {
            this.spawnBlock();
            this.nextInnerState();
        }
        else if(this.objectHandler.player.x < Align.width / 2 - 300)
        {
            this.objectHandler.player.x = Align.width / 2;
            this.spawnBlock();
        }
    }
    else if(this.innerState == 3)
    {
        if(distToPlayer < -200)
        {
            this.nextInnerState();
        }
        else if(this.objectHandler.player.x < Align.width / 2 - 300)
        {
            this.objectHandler.player.x = Align.width / 2;
            this.spawnBlock();
        }
    }
    else if(this.innerState == 4)
    {
        this.done = true;
    }
};

JumpState.prototype.draw = function(gfx)
{
    gfx.drawCenteredString("INNERSTATE: " + this.innerState, Align.width / 2, 200, "#FFF", "20pt Arial");

    if(this.done == true)
    {
        gfx.drawCenteredString("Wacht op de andere speler!", 800, 400, "#FFF", "20pt Arial");
    }
    if(this.innerState == 0)
    {
        gfx.drawCenteredString("Tutorial time", 800, 400, "#FFF", "20pt Arial");
    }
    else if(this.innerState == 1)
    {
        gfx.drawCenteredString("Springen", 800, 400, "#FFF", "20pt Arial");
    }
    else if(this.innerState == 2)
    {
        gfx.drawCenteredString("SPRINGEN", 800, 400, "#FFF", "20pt Arial");
    }
};StompState = function(firstWorld, secondWorld)
{
    this.world = firstWorld;
    this.otherWorld = secondWorld;
    this.objectHandler = this.world.objectHandler;
    this.innerState = 0;
    this.done = false;
};

StompState.prototype.nextInnerState = function()
{
    this.innerState++;
};

StompState.prototype.start = function()
{
    this.spawnBlock();
    this.innerState++;
};

StompState.prototype.handleJump = function()
{
    if(this.innerState >= 0){
        if(this.innerState == 1)
        {
            this.world.worldPaused = false;
            //this.nextInnerState();
        }
        return true;
    } else {
        return false;
    }
}

StompState.prototype.spawnBlock = function()
{
    this.world.currentObstacle = new Obstacle(this.world.dir);
    this.world.objectHandler.addObstacle(this.world.currentObstacle);
};

StompState.prototype.reset = function()
{
    this.innerState = 0;
    this.done = false;
    this.start();
};

StompState.prototype.tick = function()
{
    var distToPlayer = this.world.currentObatacleFromPlayer();

    if(this.innerState == 1)
    {
        if(distToPlayer > 0 && distToPlayer < 350)
        {
            this.world.worldPaused = true;
            // After the jump the innerState will be incremented to 2
        }
    }
    else if(this.innerState == 2)
    {
        if(this.world.objectHandler.player.y < Align.height / 2 - 600)
        {
            this.world.worldPaused = true;
            this.world.otherWorld.worldPaused = true;
        }
    }
};

StompState.prototype.draw = function(gfx)
{
    gfx.drawCenteredString("INNERSTATE: " + this.innerState, Align.width / 2, 200, "#FFF", "20pt Arial");

    if(this.done == true)
    {
        gfx.drawCenteredString("Wacht op de andere speler!", 800, 400, "#FFF", "20pt Arial");
    }
    if(this.innerState == 0)
    {
        gfx.drawCenteredString("stomp tutorial", 800, 400, "#FFF", "20pt Arial");
    }
    else if(this.innerState == 1)
    {
        gfx.drawCenteredString("inner state 1", 800, 400, "#FFF", "20pt Arial");
    }
    else if(this.innerState == 2)
    {
        gfx.drawCenteredString("inner state 2 ", 800, 400, "#FFF", "20pt Arial");
    }
};/**
 * Created by Yorick on 5/9/2014.
 */

TutorialHandler = function(item)
{
    this.item = item;

    this.world1 = new TutorialWorld(1);
    this.world2 = new TutorialWorld(-1);

    this.world1.gameHandler = this;
    this.world2.gameHandler = this;

    this.world1.otherWorld = this.world2;
    this.world2.otherWorld = this.world1;

    this.world1.initialize();
    this.world2.initialize();

    this.worldPaused = false;
};

TutorialHandler.prototype.pauseWorld = function()
{

};

TutorialHandler.prototype.tryNextState = function()
{
    // 1.) Spawn small block
    // 2.) Spawn big block
    // 3.) Start a game

    if(this.world1.currentStateDone() == true && this.world2.currentStateDone() == true)
    {
        // state++
        this.world1.nextState();
        this.world2.nextState();
    }
};

TutorialHandler.prototype.resetState = function()
{
    // 1.) Spawn small block again
    // 2.) Spawn big block again
    // 3.) can't be resetted
};

TutorialHandler.prototype.tick = function()
{
    this.world1.tick();
    this.world2.tick();

    this.tryNextState();
};

TutorialHandler.prototype.draw = function(gfx)
{
    gfx.clear("#000");

    this.world1.draw(gfx);
    this.world2.draw(gfx);
};
/**
 * Created by Jelle on 5/7/2014.
 */

TutorialObjectHandler = function(world)
{
    this.state = 0;
    this.waitCount = 0;

    this.world = world;

    // player
    this.player = new Player(this.world.dir);

    // obstacles
    this.obstacleSpawner = new ObstacleSpawner();
    this.obstacleSpawner.objectHandler = this;
    this.obstacles = [];
};

TutorialObjectHandler.prototype.initialize = function()
{
    this.player.otherPlayer = this.world.otherWorld.objectHandler.player;
};

TutorialObjectHandler.prototype.addObstacle = function(obj)
{
    this.obstacles.push(obj);
};

TutorialObjectHandler.prototype.tick = function()
{
    this.player.tick();
    //this.obstacleSpawner.tick();

    for(var i = 0; i < this.obstacles.length; i++)
    {
        this.obstacles[i].tick();
        if(this.obstacles[i].remove == true)
        {
            this.obstacles.splice(i, 1);
            i -= 1;
        }
    }
};

TutorialObjectHandler.prototype.draw = function(gfx)
{
    this.player.draw(gfx);
    //this.obstacleSpawner.draw(gfx);

    for(var i = 0; i < this.obstacles.length; i++)
    {
        this.obstacles[i].draw(gfx);
    }
};
TutorialState = function(world)
{
    this.world = world;
    this.innerState = 0;
    this.done = false;
};

TutorialState.prototype.start = function()
{

};

TutorialState.prototype.Reset = function()
{
    this.innerState = 0;
    this.done = false;
    this.start();
};

TutorialState.prototype.tick = function()
{

};

TutorialState.prototype.draw = function(gfx)
{

};/**
 * Created by Yorick on 5/9/2014.
 */

TutorialWorld = function(dir, tutorialHandler)
{
    this.dir = dir;

    this.backgroudTexture = Files.PIC_GAME__BACKGROUND.obj;

    this.buttons = [];

    var button = undefined;

    this.state = 0;
    this.stateDone = false;
    this.waitCount = 0;
    this.innerState = 0;

    // Jump button
    button = new RotatableButton();
    button.alignx = Align.LEFT;
    button.aligny = Align.TOP;
    button.setTexture(Files.PIC_GAME_BUTTON_JUMP.obj);
    button.setSize(Files.PIC_GAME_BUTTON_JUMP.obj.width, Files.PIC_GAME_BUTTON_JUMP.obj.height);

    var screenPosX = -(Align.width / 2) * (dir - 1);
    var screenPosY = -(Align.height / 2) * (dir - 1);

    var objPosX = (button.width / 2) * (dir);
    var objPosY = (button.height / 2) * (dir);

    button.setPosition(screenPosX + objPosX, screenPosY + objPosY);

    button.rotation = (dir + 1) * 90;
    button.world = this;
    button.onClick = function(){if(this.world.otherWorld.continueJump()){ this.world.otherWorld.objectHandler.player.tryJump();}};
    this.buttons.push(button);

    // Back button
    button = new RotatableButton();
    button.alignx = Align.LEFT;
    button.aligny = Align.TOP;
    button.setTexture(Files.PIC_GAME_BUTTON_BACK.obj);
    button.setSize(Files.PIC_GAME_BUTTON_BACK.obj.width, Files.PIC_GAME_BUTTON_BACK.obj.height);

    var screenPosX = (Align.width / 2) * (dir + 1);
    var screenPosY = -(Align.height / 2) * (dir - 1);

    var objPosX = -(button.width / 2) * (dir);
    var objPosY = (button.height / 2) * (dir);

    button.setPosition(screenPosX + objPosX, screenPosY + objPosY);

    button.rotation = (dir + 1) * 90;
    button.world = this;
    button.onClick = function(){this.world.gameHandler.item.itemHandler.setGotoItem(ItemMainMenu)};
    this.buttons.push(button);

    this.objectHandler = new TutorialObjectHandler(this);

    this.currentState = 0;
    this.states = [];

    var jumpState = new JumpState(this);
    jumpState.start();

    this.states.push(jumpState);

    jumpState = new StompState(this, this.otherWorld);
    jumpState.start();
    this.states.push(jumpState);

    this.worldPaused = false;
};

TutorialWorld.prototype.initialize = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].item = this.gameHandler.item;
        this.buttons[i].initialize();
    }

    this.objectHandler.initialize();
};

TutorialWorld.prototype.nextState = function()
{
    this.currentState++;
    if(this.states.length > this.currentState){
        this.states[this.currentState].start();
    }
    else
    {
        // GOTO MENU
        console.log("Tutorial done");
        this.gameHandler.item.itemHandler.setGotoItem(ItemMainMenu);
    }
};

TutorialWorld.prototype.currentStateDone = function()
{
    return this.states[this.currentState].done;
};

TutorialWorld.prototype.currentObatacleFromPlayer = function()
{
    return this.currentObstacle.x - this.objectHandler.player.x;
};

TutorialWorld.prototype.continueJump = function()
{
    return this.states[this.currentState].handleJump();
};

TutorialWorld.prototype.tick = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].tick();
    }

    if(this.states.length > this.currentState){
        this.states[this.currentState].tick();
    }

    if(!this.worldPaused){
        this.objectHandler.tick();
    }
};

TutorialWorld.prototype.TouchDownInWorld = function()
{
    if(this.gameHandler.item.itemHandler.windowHandler.isMouseDown())
    {
        var mousesdown = this.gameHandler.item.itemHandler.windowHandler.getMousesDown();
        for(var i = 0; i < mousesdown.length; i++)
        {
            if(mousesdown[i].ticksAlive == 1)
            {
                if(this.dir == -1 && mousesdown[i].y > Align.height / 2)
                {
                    //console.log("BOTTOM SCREEN!" + mousesdown[i].y);
                    return true;
                }
                else if(this.dir == 1 && mousesdown[i].y < Align.height / 2)
                {
                    //console.log("TOP SCREEN!" + mousesdown[i].y);
                    return true;
                }
            }
        }
    }
    return false;
}

TutorialWorld.prototype.draw = function(gfx)
{
    // prepare draw
    gfx.gfx.save();
    gfx.gfx.scale(1, this.dir);
    gfx.gfx.translate(0, (Align.height / 2) * (this.dir - 1));

    gfx.drawCenteredString("State = " + this.currentState, Align.width / 2, 300, "#FFF", "20pt Arial");

    this.objectHandler.draw(gfx);

    if(this.states.length > this.currentState){
        this.states[this.currentState].draw(gfx);
    }

    gfx.gfx.restore();

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].draw(gfx);
    }
};
/**
 * Created by Jelle on 5/6/2014.
 */

GameHandler = function(item)
{
    this.item = item;

    this.sharedSpawnOptions = new SharedSpawnOptions();

    this.world1 = new World(1);
    this.world2 = new World(-1);

    this.world1.gameHandler = this;
    this.world2.gameHandler = this;

    this.world1.otherWorld = this.world2;
    this.world2.otherWorld = this.world1;

    this.world1.initialize();
    this.world2.initialize();
};

GameHandler.prototype.tick = function()
{
    this.world1.tick();
    this.world2.tick();
};

GameHandler.prototype.draw = function(gfx)
{
    gfx.clear("#000");

    this.world1.draw(gfx);
    this.world2.draw(gfx);
};
/**
 * Created by Jelle on 5/6/2014.
 */

ItemGame = function()
{
    this.gameHandler = new GameHandler(this);
};

ItemGame.prototype.initialize = function()
{
};

ItemGame.prototype.activate = function()
{
};

ItemGame.prototype.deActivate = function()
{
};

ItemGame.prototype.tick = function()
{
    this.gameHandler.tick();
};

ItemGame.prototype.draw = function(gfx)
{
    this.gameHandler.draw(gfx);
};
/**
 * Created by Yorick on 5/6/2014.
 */

ItemTutorial = function()
{
    this.tutHandler = new TutorialHandler(this);
};

ItemTutorial.prototype.initialize = function()
{
};

ItemTutorial.prototype.activate = function()
{
};

ItemTutorial.prototype.deActivate = function()
{
};

ItemTutorial.prototype.tick = function()
{
    this.tutHandler.tick();
};

ItemTutorial.prototype.draw = function(gfx)
{
    this.tutHandler.draw(gfx);
    //gfx.clear('#000000');
    //gfx.fillRect(10, 10, 100, 100, "#FF0000");
};
/**
 * Created by Jelle on 5/7/2014.
 */

ItemCreditsMenu = function()
{
    this.backgroundTexture = Files.PIC_MENU_BACKGROUND.obj;

    this.lastMouseX = 0;
    this.lastMouseY = 0;

    this.backButton = new Button();
    this.backButton.alignx = Align.CENTER;
    this.backButton.aligny = Align.CENTER;
    this.backButton.setTexture(Files.PIC_MENU_BUTTON_BACK.obj);
    this.backButton.setPosition(0, 0);
    this.backButton.setSize(Files.PIC_MENU_BUTTON_BACK.obj.width, Files.PIC_MENU_BUTTON_BACK.obj.height);
    this.backButton.onClick = function(){this.item.itemHandler.setGotoItem(ItemMainMenu);};
};

ItemCreditsMenu.prototype.initialize = function()
{
    this.backButton.item = this;
    this.backButton.initialize();
};

ItemCreditsMenu.prototype.activate = function()
{
};

ItemCreditsMenu.prototype.deActivate = function()
{
};

ItemCreditsMenu.prototype.tick = function()
{
    this.backButton.tick();
};

ItemCreditsMenu.prototype.draw = function(gfx)
{
    gfx.clear("black");
    //gfx.drawTexture(this.backgroundTexture, 0, 0, Align.width, Align.height);

    this.backButton.draw(gfx);
};
/**
 * Created by Jelle on 4/27/2014.
 */

ItemMainMenu = function()
{
    this.backgroundTexture = Files.PIC_MENU_BACKGROUND.obj;

    this.buttons = [];

    var button = undefined;

    // Play button
    button = new Button();
    button.alignx = Align.CENTER;
    button.aligny = Align.CENTER;
    button.setTexture(Files.PIC_MENU_BUTTON_PLAY.obj);
    button.setPosition(0, -350);
    button.setSize(Files.PIC_MENU_BUTTON_PLAY.obj.width - 50, Files.PIC_MENU_BUTTON_PLAY.obj.height - 50);
    button.onClick = function(){this.item.itemHandler.setGotoItem(ItemGame);};
    this.buttons.push(button);

    // Options button
    button = new Button();
    button.alignx = Align.CENTER;
    button.aligny = Align.CENTER;
    button.setTexture(Files.PIC_MENU_BUTTON_OPTIONS.obj);
    button.setPosition(0, 0);
    button.setSize(Files.PIC_MENU_BUTTON_OPTIONS.obj.width - 50, Files.PIC_MENU_BUTTON_OPTIONS.obj.height - 50);
    button.onClick = function(){this.item.itemHandler.setGotoItem(ItemOptionsMenu);};
    this.buttons.push(button);

    // Credits button
    button = new Button();
    button.alignx = Align.CENTER;
    button.aligny = Align.CENTER;
    button.setTexture(Files.PIC_MENU_BUTTON_CREDITS.obj);
    button.setPosition(0, 350);
    button.setSize(Files.PIC_MENU_BUTTON_CREDITS.obj.width - 50, Files.PIC_MENU_BUTTON_CREDITS.obj.height - 50);
    button.onClick = function(){this.item.itemHandler.setGotoItem(ItemCreditsMenu);};
    this.buttons.push(button);

    SFX.setBackgroundSound(Files.SND_MENU_BACKGROUND);
};

ItemMainMenu.prototype.initialize = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].item = this;
        this.buttons[i].initialize();
    }
};

ItemMainMenu.prototype.activate = function()
{

};

ItemMainMenu.prototype.deActivate = function()
{

};

ItemMainMenu.prototype.tick = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].tick();
    }
};

ItemMainMenu.prototype.draw = function(gfx)
{
    gfx.clear("black");
    gfx.drawTexture(this.backgroundTexture, 0, 0, Align.width, Align.height);

    var mouses = this.itemHandler.windowHandler.getMousesDown();
    for(var i = 0; i < mouses.length; i++)
    {
        gfx.fillRect(mouses[i].x - 10, mouses[i].y - 10, 20, 20, "yellow");
    }

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].draw(gfx);
    }

    gfx.drawString("Navigator: " + navigator.isCocoonJS, 10, 40, "#FF0", "30px Arial");
};
/**
 * Created by Jelle on 5/7/2014.
 */

ItemOptionsMenu = function()
{
    this.buttons = [];

    var button = undefined;

    // Back button
    button = new Button();
    button.alignx = Align.CENTER;
    button.aligny = Align.CENTER;
    button.setTexture(Files.PIC_MENU_BUTTON_BACK.obj);
    button.setPosition(0, 350);
    button.setSize(Files.PIC_MENU_BUTTON_BACK.obj.width - 50, Files.PIC_MENU_BUTTON_BACK.obj.height - 50);
    button.onClick = function(){this.item.itemHandler.setGotoItem(ItemMainMenu);};
    this.buttons.push(button);
};

ItemOptionsMenu.prototype.initialize = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].item = this;
        this.buttons[i].initialize();
    }
};

ItemOptionsMenu.prototype.activate = function()
{
};

ItemOptionsMenu.prototype.deActivate = function()
{
};

ItemOptionsMenu.prototype.tick = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].tick();
    }
};

ItemOptionsMenu.prototype.draw = function(gfx)
{
    gfx.clear("#000");

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].draw(gfx);
    }
};
/**
 * Created by Jelle on 4/29/2014.
 */

ItemTestMenu = function()
{
    this.firstDraw = true;
};

ItemTestMenu.prototype.initialize = function()
{
};

ItemTestMenu.prototype.activate = function()
{
};

ItemTestMenu.prototype.deActivate = function()
{
};

ItemTestMenu.prototype.tick = function()
{
};

ItemTestMenu.prototype.draw = function(gfx)
{
    if(this.firstDraw == true)
    {
        this.firstDraw = false;
        gfx.clear("#FFF");
    }

    if(this.itemHandler.windowHandler.isMouseDown())
    {
        var mousesdown = this.itemHandler.windowHandler.getMousesDown();
        for (var i = 0; i < mousesdown.length; i++)
        {
            if(mousesdown[i].lastX != mousesdown[i].x || mousesdown[i].lastY != mousesdown[i].y)
            {
                gfx.drawLine(mousesdown[i].lastX, mousesdown[i].lastY, mousesdown[i].x - mousesdown[i].lastX, mousesdown[i].y - mousesdown[i].lastY, mousesdown[i].color, 10);
            }
        }
    }
};
/**
 * Created by Jelle on 4/26/2014.
 */

ItemInitialize = function(){};

ItemInitialize.prototype.initialize = function()
{
    this.loader = new Loader(Files.prefiles);
    this.loader.start();
};

ItemInitialize.prototype.activate = function()
{

};

ItemInitialize.prototype.deActivate = function()
{

};

ItemInitialize.prototype.tick = function()
{
    if(this.loader.done == true)
    {
        this.itemHandler.setGotoItem(ItemLoader);
    }
};

ItemInitialize.prototype.draw = function(gfx)
{
    gfx.clear("black");
};
/**
 * Created by Jelle on 4/26/2014.
 */

ItemLoader = function()
{
    this.backgroundTexture = Files.PIC_LOADER_BACKGROUND.obj;

    this.loader = new Loader(Files.files);
    this.loader.start();
};

ItemLoader.prototype.initialize = function()
{

};

ItemLoader.prototype.activate = function()
{

};

ItemLoader.prototype.deActivate = function()
{

};

ItemLoader.prototype.tick = function()
{
    if(this.loader.done == true)
    {
        this.itemHandler.setGotoItem(ItemMainMenu);
    }
};

ItemLoader.prototype.draw = function(gfx)
{
    gfx.clear("black");
    gfx.drawTexture(this.backgroundTexture, 0, 0, Align.width, Align.height);

    gfx.drawCenteredString("Loading...", Align.width / 2, Align.height / 2, "black", "120px Arial");
};
/**
 * Created by Jelle on 4/25/2014.
 */

FileComponent = function()
{
    this.path = "";
    this.obj = null;
};

Files = function(){};
Files.prefiles = [];
Files.files = [];
Files.addPreFile = function(path)
{
    if(path != undefined && path != "")
    {
        var component = new FileComponent();
        component.path = path;

        Files.prefiles.push(component);
        return component;
    }
};

Files.addFile = function(path)
{
    if(path != undefined && path != "")
    {
        var component = new FileComponent();
        component.path = path;

        Files.files.push(component);
        return component;
    }
};

//////// ----- PreFile list ----- ////////
Files.PIC_LOADER_BACKGROUND = Files.addPreFile("PreAssets/background.jpg");

//////// ----- File list ----- ////////
Files.PIC_MENU_BACKGROUND = Files.addFile("Assets/Menu/Background.jpg");
Files.PIC_MENU_BUTTON_PLAY = Files.addFile("Assets/Menu/PlayButton.png");
Files.PIC_MENU_BUTTON_OPTIONS = Files.addFile("Assets/Menu/OptionsButton.png");
Files.PIC_MENU_BUTTON_CREDITS = Files.addFile("Assets/Menu/CreditsButton.png");
Files.PIC_MENU_BUTTON_BACK = Files.addFile("Assets/Menu/BackButton.png");

Files.SND_MENU_BACKGROUND = "Assets/Menu/Background.ogg";

Files.PIC_GAME__BACKGROUND = Files.addFile("Assets/Game/Background.jpg");

Files.PIC_GAME_BUTTON_JUMP = Files.addFile("Assets/Game/JumpButton.png");
Files.PIC_GAME_BUTTON_BACK = Files.addFile("Assets/Game/BackButton.png");

Files.PIC_GAME_OBJECT_PLAYER = Files.addFile("Assets/Game/Objects/Player.png");
Files.PIC_GAME_OBJECT_OBSTACLEWALLNORMAL = Files.addFile("Assets/Game/Objects/ObstacleWallNormal.png");
/**
 * Created by Jelle on 4/25/2014.
 */

// run main when the document is ready
window.onload = function(){new Main();};

Main = function()
{
    console.log("Starting...");
    Arguments.initialize();
    var mywindow = new WindowHandler();
};
