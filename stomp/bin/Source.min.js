/*
    Minified by Jellevdg3's minifier at 14/May/2014 14:54:33.
*/
/**
 * Created by Jelle on 4/28/2014.
 */

Align = function(ratiox, ratioy)
{
    this.ratiox = ratiox;
    this.ratioy = ratioy;

    this.set();

    Align.aligns.push(this);
};

Align.aligns = [];

Align.screenW = 0;
Align.screenH = 0;

Align.width = 1920;
Align.height = 1080;

Align.ratiox = 0;
Align.ratioy = 0;

Align.setSS = function(w, h)
{
    Align.screenW = w;
    Align.screenH = h;

    Align.ratiox = Align.screenW / Align.width;
    Align.ratioy = Align.screenH / Align.height;

    Align.ratiorevx = Align.width / Align.screenW;
    Align.ratiorevy = Align.height / Align.screenH;

    for(var i = 0; i < Align.aligns.length; i++)
    {
        Align.aligns[i].set();
    }
};

Align.prototype.set = function()
{
    this.sw = this.x(Align.width);
    this.sh = this.y(Align.height);
};

Align.prototype.sx = function()
{
    return this.sw;
};

Align.prototype.sy = function()
{
    return this.sh;
};

Align.prototype.x = function(w)
{
    return parseInt(w * this.ratiox);
};

Align.prototype.y = function(h)
{
    return parseInt(h * this.ratioy);
};

Align.LEFT = new Align(0.0, 0.0);
Align.TOP = new Align(0.0, 0.0);
Align.CENTER = new Align(0.5, 0.5);
Align.RIGHT = new Align(1.0, 0.0);
Align.BOTTOM = new Align(0.0, 1.0);
/**
 * Created by Jelle on 4/27/2014.
 */

Button = function()
{
    this.texture = null;
    this.x = 0;
    this.y = 0;
    this.width = 100;
    this.height = 100;

    this.item = undefined;

    this.alignx = Align.LEFT;
    this.aligny = Align.TOP;
};

Button.prototype.setTexture = function(texture)
{
    this.texture = texture;
};

Button.prototype.setPosition = function(x, y)
{
    this.x = x;
    this.y = y;
};

Button.prototype.setSize = function(width, height)
{
    this.width = width;
    this.height = height;
};

Button.prototype.initialize = function()
{
    if(this.item == undefined)
    {
        console.error("Item is undefined.");
    }

    this.x -= parseInt(this.width / 2);
    this.y -= parseInt(this.height / 2);
};

Button.prototype.tick = function()
{
    if(this.item.itemHandler.windowHandler.isMouseDown())
    {
        var mousesdown = this.item.itemHandler.windowHandler.getMousesDown();
        for(var i = 0; i < mousesdown.length; i++)
        {
            if(mousesdown[i].ticksAlive == 1 && mousesdown[i].x >= this.alignx.sx() + this.x && mousesdown[i].y >= this.aligny.sy() + this.y && mousesdown[i].x < this.alignx.sx() + this.x + this.width && mousesdown[i].y < this.aligny.sy() + this.y + this.height)
            {
                this.onClick();
                break;
            }
        }
    }
};

Button.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.texture, this.alignx.sx() + this.x, this.aligny.sy() + this.y, this.width, this.height);
};

// events
Button.prototype.onClick = function(){};
/**
 * Created by Jelle on 5/6/2014.
 */

RotatableButton = function()
{
    this.texture = null;
    this.x = 0;
    this.y = 0;
    this.width = 100;
    this.height = 100;
    this.rotation = 0;

    this.item = undefined;

    this.alignx = Align.LEFT;
    this.aligny = Align.TOP;
};

RotatableButton.prototype.setTexture = function(texture)
{
    this.texture = texture;
};

RotatableButton.prototype.setPosition = function(x, y)
{
    this.x = x;
    this.y = y;
};

RotatableButton.prototype.setSize = function(width, height)
{
    this.width = width;
    this.height = height;
};

RotatableButton.prototype.initialize = function()
{
    if(this.item == undefined)
    {
        console.error("Item is undefined.");
    }

    this.x -= parseInt(this.width / 2);
    this.y -= parseInt(this.height / 2);
};

RotatableButton.prototype.tick = function()
{
    if(this.item.itemHandler.windowHandler.isMouseDown())
    {
        var mousesdown = this.item.itemHandler.windowHandler.getMousesDown();
        for(var i = 0; i < mousesdown.length; i++)
        {
            if(mousesdown[i].ticksAlive == 1 && mousesdown[i].x >= this.alignx.sx() + this.x && mousesdown[i].y >= this.aligny.sy() + this.y && mousesdown[i].x < this.alignx.sx() + this.x + this.width && mousesdown[i].y < this.aligny.sy() + this.y + this.height)
            {
                this.onClick();
                break;
            }
        }
    }
};

RotatableButton.prototype.draw = function(gfx)
{
    gfx.drawRotatedTexture(this.texture, this.alignx.sx() + this.x, this.aligny.sy() + this.y, this.width, this.height, this.rotation);
};

// events
RotatableButton.prototype.onClick = function(){};
/**
 * Created by Jelle on 4/25/2014.
 */

Canvas = function()
{
    this.canvas = document.createElement("canvas");
    document.body.appendChild(this.canvas);
    this.gfx = new GFX(this);

    this.rescale();
};

Canvas.prototype.rescale = function()
{
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.x = 0;
    this.y = 0;

    this.canvasWidth = this.width;
    this.canvasHeight = this.height;

    var arg_width = Arguments.get("w");
    var arg_height = Arguments.get("h");

    if(arg_width != undefined)
    {
        this.canvasWidth = parseInt(arg_width);
    }

    if(arg_height != undefined)
    {
        this.canvasHeight = parseInt(arg_height);
    }

    console.log("Canvas rescaling to " + this.canvasWidth + "x" + this.canvasHeight + ";");

    this.canvas.width = this.canvasWidth;
    this.canvas.height = this.canvasHeight;

    this.canvas.style.position = "absolute";
    this.canvas.style.width = window.innerWidth + "px";
    this.canvas.style.height = window.innerHeight + "px";
    this.canvas.style.left = 0 + "px";
    this.canvas.style.top = 0 + "px";
    this.canvas.style.imageRendering = "-webkit-optimize-contrast";

    // rotate
    this.rotated = false;
    this.gfx.gfx.translate(0, 0);
    this.gfx.gfx.rotate(0);
    this.gfx.gfx.scale(1, 1);

    if(this.height > this.width)
    {
        Align.setSS(this.height, this.width);

        this.rotated = true;

        this.gfx.gfx.scale(this.canvasWidth / Align.height, this.canvasHeight / Align.width);
        this.gfx.gfx.translate(Align.height, 0);
        this.gfx.gfx.rotate(90 * Math.PI / 180);
    }
    else
    {
        Align.setSS(this.width, this.height);
        this.gfx.gfx.rotate(0);
        this.gfx.gfx.scale(this.canvasWidth / Align.width, this.canvasHeight / Align.height);
    }
};
/**
 * Created by Jelle on 4/25/2014.
 */

GFX = function(canvas)
{
    this.canvas = canvas;
    this.gfx = this.canvas.canvas.getContext("2d");

    this.gfx.imageSmoothingEnabled = false;
    this.gfx.mozImageSmoothingEnabled = false;
    this.gfx.webkitImageSmoothingEnabled = false;

    this.gfx.save();
};

GFX.prototype.clear = function(style)
{
    this.gfx.fillStyle = style;
    this.gfx.fillRect(0, 0, Align.width, Align.height);
};

GFX.prototype.drawLine = function(x, y, w, h, strokeStyle, lineWidth)
{
    this.gfx.lineWidth = lineWidth;
    this.gfx.strokeStyle = strokeStyle;
    this.gfx.beginPath();
    this.gfx.moveTo(x, y);
    this.gfx.lineTo(x + w, y + h);
    this.gfx.stroke();
};

GFX.prototype.drawCurve = function(x1, y1, x2, y2, x3, y3, strokeStyle, lineWidth)
{
    this.gfx.lineWidth = lineWidth;
    this.gfx.strokeStyle = strokeStyle;
    this.gfx.beginPath();
	this.gfx.quadraticCurveTo(x1, y1, x2, y2);
	this.gfx.quadraticCurveTo(x2, y2, x3, y3);
    this.gfx.stroke();
};

GFX.prototype.fillCircle = function(x, y, radius, fillStyle)
{
    this.gfx.fillStyle = fillStyle;
    this.gfx.beginPath();
	this.gfx.arc(x, y, radius, 0, 2 * Math.PI);
    this.gfx.fill();
};

GFX.prototype.drawRect = function(x, y, w, h, strokeStyle, lineWidth)
{
    this.gfx.lineWidth = lineWidth;
    this.gfx.strokeStyle = strokeStyle;
    this.gfx.strokeRect(x, y, w, h);
};

GFX.prototype.fillRect = function(x, y, w, h, fillStyle)
{
    this.gfx.fillStyle = fillStyle;
    this.gfx.fillRect(x, y, w, h);
};

GFX.prototype.drawString = function(text, x, y, fillstyle, font)
{
    this.gfx.fillStyle = fillstyle;
    this.gfx.font = font;
    this.gfx.fillText(text, x, (y + 6));
};

GFX.prototype.drawCenteredString = function(text, x, y, fillstyle, font)
{
    var metrics = this.gfx.measureText(text);
    this.drawString(text, (x - (metrics.width / 2)), y, fillstyle, font);
};

GFX.prototype.drawTexture = function(texture, x, y, width, height)
{
    this.gfx.drawImage(texture, x, y, width, height);
};

GFX.prototype.drawRotatedTexture = function(texture, x, y, width, height, rotation)
{
    this.gfx.save();

    this.gfx.translate(x + (width / 2), y + (height / 2));

    this.gfx.rotate(rotation * (Math.PI / 180));

    this.gfx.drawImage(texture, -(width / 2), -(height / 2), width, height);

    this.gfx.restore();
};

GFX.prototype.drawTransparentTexture = function(texture, x, y, width, height, alpha)
{
    this.gfx.globalAlpha = alpha;
    this.gfx.drawImage(texture, x, y, width, height);
    this.gfx.globalAlpha = 1.0;
};

GFX.prototype.drawClippedTexture = function(texture, x, y, width, height, cx, cy, cwidth, cheight)
{
    this.gfx.drawImage(texture, cx, cy, cwidth, cheight, x, y, width, height);
};
/**
 * Created by Jelle on 5/8/2014.
 */

KeyEvent = function()
{
    this.keyCode = 0;
    this.ticksAlive = 0;
    this.isDown = false;
    this.remove = false;
};

KeyEvent.prototype.tick = function()
{
    console.log("Key down: " + this.keyCode);
};
/**
 * Created by Jelle on 5/5/2014.
 */

MouseEvent = function()
{
    this.x = 0;
    this.y = 0;
    this.newX = 0;
    this.newY = 0;
    this.lastX = 0;
    this.lastY = 0;
    this.ticksAlive = 0;
    this.remove = false;
    this.isMouse = false;
    this.isTouch = false;
};

MouseEvent.prototype.tick = function()
{
    this.ticksAlive++;

	this.beforeLastX = this.lastX;
	this.beforeLastY = this.lastY;
	
    this.lastX = this.x;
    this.lastY = this.y;

    this.x = this.newX;
    this.y = this.newY;
};
/**
 * Created by Jelle on 4/25/2014.
 */

WindowKeyboardListener = function()
{
    this.keys = [];
    for(var i = 0; i < 256; i++)
    {
        var keyEvent = new KeyEvent();
        keyEvent.keyCode = i;
        this.keys.push(keyEvent);
    }

    this.keysDown = [];

    window.onkeydown = new EventHandler(this, this.onKeyDown);
    window.onkeyup = new EventHandler(this, this.onKeyUp);
};

WindowKeyboardListener.prototype.tick = function()
{
    for(var i = 0; i < this.keysDown.length; i++)
    {
        this.keysDown[i].tick();

        if(this.keysDown[i].remove == true)
        {
            this.keysDown[i].remove = false;
            this.keysDown[i].isDown = false;
            this.keysDown[i].ticksAlive = 0;

            this.keysDown.splice(i, 1);
            i--;
        }
    }
};

// events
WindowKeyboardListener.prototype.onKeyDown = function(ev)
{
    ev.preventDefault();

    var keyCode = ev.keyCode;
    var keyEvent = this.keys[keyCode];
    this.keysDown.push(keyEvent);

    keyEvent.isDown = true;
};

WindowKeyboardListener.prototype.onKeyUp = function(ev)
{
    ev.preventDefault();

    var keyCode = ev.keyCode;
    var keyEvent = this.keys[keyCode];
    keyEvent.remove = true;
};
/**
 * Created by Jelle on 4/25/2014.
 */

WindowMouseListener = function()
{
    this.mousedown = [];
    this.touchIdToMouseEvent = [];
    this.mouseButtonToMouseEvent = [];

    this.isMouseDown = false;

    // mouse down
    window.onmousedown = new EventHandler(this, this.onMouseDown);
    window.onmousemove = new EventHandler(this, this.onMouseMove);
    window.onmouseup = new EventHandler(this, this.onMouseUp);

    window.ontouchstart = new EventHandler(this, this.onTouchDown);
    window.ontouchmove = new EventHandler(this, this.onTouchMove);
    window.ontouchend = new EventHandler(this, this.onTouchUp);
    window.ontouchcancel = new EventHandler(this, this.onTouchUp);

    window.oncontextmenu = function(){return false;};
};

WindowMouseListener.prototype.tick = function()
{
    for(var i = 0; i < this.mousedown.length; i++)
    {
        this.mousedown[i].tick();
        if(this.mousedown[i].remove == true)
        {
            if(this.mousedown[i].isMouse == true)
            {
                this.mouseButtonToMouseEvent[this.mousedown[i].id] = null;
            }

            if(this.mousedown[i].isTouch == true)
            {
                this.touchIdToMouseEvent[this.mousedown[i].id] = null;
            }
            this.mousedown.splice(i, 1);
            i--;
        }
    }

    this.isMouseDown = this.mousedown.length != 0;
};

WindowMouseListener.prototype.setMousePosition = function(mouseEvent, rx, ry)
{
    if(this.windowHandler.canvas.rotated == true)
    {
        mouseEvent.newY = Align.height - ((rx - this.windowHandler.canvas.x) * Align.ratiorevy);
        mouseEvent.newX = ((ry - this.windowHandler.canvas.y) * Align.ratiorevx);
    }
    else
    {
        mouseEvent.newX = ((rx - this.windowHandler.canvas.x) * Align.ratiorevx);
        mouseEvent.newY = ((ry - this.windowHandler.canvas.y) * Align.ratiorevy);
    }
};

// events
WindowMouseListener.prototype.onMouseDown = function(ev)
{
    ev.preventDefault();

    var id = parseInt(ev.button);

    var mouseEvent = new MouseEvent();

    mouseEvent.isMouse = true;

    mouseEvent.id = id;

    this.setMousePosition(mouseEvent, ev.pageX, ev.pageY);

    mouseEvent.lastX = mouseEvent.newX;
    mouseEvent.lastY = mouseEvent.newY;
    mouseEvent.x = mouseEvent.newX;
    mouseEvent.y = mouseEvent.newY;

    this.mouseButtonToMouseEvent[id] = mouseEvent;

    this.mousedown.push(mouseEvent);
};

WindowMouseListener.prototype.onMouseMove = function(ev)
{
    ev.preventDefault();

    var id = parseInt(ev.button);
    var mouseEvent = this.mouseButtonToMouseEvent[id];

    if(mouseEvent != undefined)
    {
        this.setMousePosition(mouseEvent, ev.pageX, ev.pageY);
    }
};

WindowMouseListener.prototype.onMouseUp = function(ev)
{
    ev.preventDefault();

    var id = parseInt(ev.button);
    var mouseEvent = this.mouseButtonToMouseEvent[id];

    mouseEvent.remove = true;
};

WindowMouseListener.prototype.onTouchDown = function(ev)
{
    ev.preventDefault();

    for(var i = 0; i < ev.changedTouches.length; i++)
    {
        var touch = ev.changedTouches[i];
        var id = parseInt(touch.identifier);

        var mouseEvent = new MouseEvent();

        mouseEvent.isTouch = true;

        mouseEvent.id = id;

        this.setMousePosition(mouseEvent, touch.pageX, touch.pageY);

        mouseEvent.lastX = mouseEvent.newX;
        mouseEvent.lastY = mouseEvent.newY;
        mouseEvent.x = mouseEvent.newX;
        mouseEvent.y = mouseEvent.newY;

        this.touchIdToMouseEvent[id] = mouseEvent;

        this.mousedown.push(mouseEvent);
    }
};

WindowMouseListener.prototype.onTouchMove = function(ev)
{
    ev.preventDefault();

    for(var i = 0; i < ev.changedTouches.length; i++)
    {
        var touch = ev.changedTouches[i];
        var id = parseInt(touch.identifier);
        var mouseEvent = this.touchIdToMouseEvent[id];

        this.setMousePosition(mouseEvent, touch.pageX, touch.pageY);
    }
};

WindowMouseListener.prototype.onTouchUp = function(ev)
{
    ev.preventDefault();

    for(var i = 0; i < ev.changedTouches.length; i++)
    {
        var touch = ev.changedTouches[i];
        var id = parseInt(touch.identifier);
        var mouseEvent = this.touchIdToMouseEvent[id];
        mouseEvent.remove = true;
    }
};
/**
 * Created by Jelle on 4/25/2014.
 */

SFX = function(){};

SFX.volume = 0.0;

SFX.setVolume = function(volume)
{
    SFX.volume = volume;
    if(SFX.backgroundSound != undefined)
    {
        SFX.backgroundSound.volume = volume;
    }
};

SFX.backgroundSound = undefined;
SFX.backgroundSoundSrc = undefined;

SFX.setBackgroundSound = function(src)
{
    SFX.stopBackgroundSound();

    SFX.backgroundSound = new Audio();
    SFX.backgroundSound.volume = SFX.volume;

    SFX.backgroundSound.addEventListener("canplay", function()
    {
        console.log("Play BackgroundSound " + src + ".");

        SFX.backgroundSound.play();

        SFX.backgroundSound.addEventListener("ended", function()
        {
            console.log("Ended BackgroundSound " + src + ".");

            SFX.setBackgroundSound(SFX.backgroundSoundSrc);
        }, false);
    }, false);

    SFX.backgroundSoundSrc = src;
    SFX.backgroundSound.src = src;
    SFX.backgroundSound.load();
};

SFX.stopBackgroundSound = function()
{
    if(SFX.backgroundSound != undefined)
    {
        SFX.backgroundSound.pause();
        SFX.backgroundSound.currentTime = 0;
        SFX.backgroundSound.src = "";

        SFX.backgroundSound = undefined;
    }
};

SFX.playSound = function(src)
{
    var audio = new Audio();
    audio.volume = SFX.volume / 4;

    audio.addEventListener("canplay", function()
    {
        audio.play();
    });

    audio.src = src;
    audio.load();
};
/**
 * Created by Jelle on 4/25/2014.
 */

Arguments = function(){};

Arguments.args = [];

Arguments.add = function(key, value)
{
    Arguments.args[key] = value;
};

Arguments.initialize = function()
{
    var location = window.location.href.toString();

    if(location.indexOf("?") != -1)
    {
        var arguments = location.substr(location.indexOf("?") + 1).split("&");

        for(var i = 0; i < arguments.length; i++)
        {
            var data = arguments[i].split("=");

            if(data.length == 2)
            {
                var key = data[0];
                var value = data[1];
                if(key != undefined && value != undefined)
                {
                    Arguments.add(key, value);
                }
            }
        }
    }
};

Arguments.get = function(key)
{
    return Arguments.args[key];
};
/**
 * Created by Jelle on 4/26/2014.
 */

EventHandler = function(object, executeFunction)
{
    this.object = object;
    this.executeFunction = executeFunction;

    var instance = this;
    this.execute = function(args)
    {
        instance.executeFunction.call(instance.object, args);
    };
	
	return this.execute;
};
/**
 * Created by Jelle on 4/26/2014.
 */

ItemHandler = function()
{
    this.curItem = null;
    this.gotoItem = null;

    this.loadedItems = [];
};

ItemHandler.prototype.setGotoItem = function(item)
{
    this.gotoItem = item;
};

ItemHandler.prototype.tick = function()
{
    if(this.gotoItem != null)
    {
        if(this.curItem != null)
        {
            this.curItem.deActivate();
        }

        var found = null;
        for(var i = 0; i < this.loadedItems.length; i++)
        {
            if(this.loadedItems[i].constructor == this.gotoItem)
            {
                found = this.loadedItems[i];
                break;
            }
        }

        if(found == undefined)
        {
            this.curItem = new this.gotoItem();
            this.loadedItems.push(this.curItem);
        }
        else
        {
            this.curItem = found;
        }

        this.gotoItem = null;

        if(!this.curItem.hasInitialized)
        {
            this.curItem.itemHandler = this;
            this.curItem.hasInitialized = true;
            this.curItem.initialize();
        }

        this.curItem.activate();
    }

    this.curItem.tick();
};

ItemHandler.prototype.draw = function(gfx)
{
    this.curItem.draw(gfx);
};
/**
 * Created by Jelle on 4/25/2014.
 */

Loader = function(fileComponents)
{
    this.completeEventHandler = new EventHandler(this, this.loadComplete);

    this.fileComponents = fileComponents;
    this.index = 0;
    this.length = this.fileComponents.length;
    this.done = false;
};

Loader.prototype.start = function()
{
    if(this.hasNext() == true)
    {
        this.loadNext();
    }
    else
    {
        this.done = true;
    }
};

Loader.prototype.stringEndsWidth = function(text, suffix)
{
    return text.indexOf(suffix, text.length - suffix.length) !== -1;
};

Loader.prototype.hasNext = function()
{
    return this.index < this.length;
};

Loader.prototype.loadImage = function(path)
{
    console.log("Image path: " + path);
    var obj = new Image();
    obj.onload = this.completeEventHandler;
    obj.onerror = this.completeEventHandler;
    obj.src = path;
    return obj;
};

Loader.prototype.loadNext = function()
{
    if(this.stringEndsWidth(this.fileComponents[this.index].path, ".jpg"))
    {
        this.fileComponents[this.index].obj = this.loadImage(this.fileComponents[this.index].path);
    }

    if(this.stringEndsWidth(this.fileComponents[this.index].path, ".png"))
    {
        this.fileComponents[this.index].obj = this.loadImage(this.fileComponents[this.index].path);
    }
};

Loader.prototype.loadComplete = function()
{
    this.index += 1;

    if(this.hasNext() == true)
    {
        this.loadNext();
    }
    else
    {
        this.done = true;
    }
};
/**
 * Created by Jelle on 4/25/2014.
 */

Ticker = function()
{
    this.tickEventHandler = new EventHandler(this, this.tick);

    this.fps = 60;

    this.curTime = 0;
    this.lastTickTime = 0;
    this.curFPSCount = 0;
    this.lastFPSCountTime = 0;
    this.curFPS = 0;
    this.lastSleep = 0;
    this.restSleep = 0;

    this.handler = function(){};
    this.handler.tick = function(){};
};

Ticker.prototype.start = function()
{
    this.curTime = this.getCurTime();
    this.lastTickTime = this.curTime;
    this.lastFPSCountTime = this.curTime;
    setTimeout(this.tickEventHandler, 1);
};

Ticker.prototype.getCurTime = function()
{
    return Date.now();
};

Ticker.prototype.tick = function()
{
    // execute
    this.handler.tick();

    // calculate
    this.lastTickTime = this.curTime + this.lastSleep;
    this.curTime = this.getCurTime();

    if(this.curTime - this.lastFPSCountTime >= 1000)
    {
        this.lastFPSCountTime = this.curTime;
        this.curFPS = this.curFPSCount;
        console.log("FPS: " + this.curFPS);
        this.curFPSCount = 0;
    }

    this.curFPSCount++;

    var delta = this.curTime - this.lastTickTime;
    var sleep = (1000.0 / this.fps) - delta + this.restSleep;
    this.restSleep = sleep % 1;

    // sleep
    if(sleep >= 1)
    {
        sleep = parseInt(sleep);
        this.lastSleep = sleep;
        setTimeout(this.tickEventHandler, sleep);
    }
    else
    {
        this.lastSleep = 1;
        setTimeout(this.tickEventHandler, 1);
    }
};
/**
 * Created by Jelle on 4/25/2014.
 */
/**
 * Created by Jelle on 4/26/2014.
 */

WindowHandler = function()
{
    // prepare body
    document.body.style.overflow = "hidden";

    // add components
    this.canvas = new Canvas();
    this.gfx = this.canvas.gfx;
    this.keyboardListener = new WindowKeyboardListener();
    this.mouseListener = new WindowMouseListener();

    this.keyboardListener.windowHandler = this;
    this.mouseListener.windowHandler = this;

    this.ticker = new Ticker();
    this.itemHandler = new ItemHandler();
    this.itemHandler.windowHandler = this;

    this.ticker.handler = this;
    this.itemHandler.setGotoItem(ItemInitialize);

    // events
    window.onfocus = function(){};
    window.onblur = function(){};

    this.ticker.start();
};

WindowHandler.prototype.isMouseDown = function()
{
    return this.mouseListener.isMouseDown;
};

WindowHandler.prototype.getMousesDown = function()
{
    return this.mouseListener.mousedown;
};

WindowHandler.prototype.tick = function()
{
    // check if should rescale
    if(window.innerWidth != this.canvas.width || window.innerHeight != this.canvas.height)
    {
        this.canvas.rescale();
    }

    this.mouseListener.tick();
    this.keyboardListener.tick();

    this.itemHandler.tick();
    this.itemHandler.draw(this.gfx);
};

// events

/**
 * Created by Jelle on 5/7/2014.
 */

CollisionBox = function(x, y, width, height)
{
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
};

CollisionBox.prototype.isCollidingWith = function(box)
{
    var tx1 = this.container.owner.x + this.x;
    var ty1 = this.container.owner.y + this.y;
    var tx2 = tx1 + this.width;
    var ty2 = ty1 + this.height;

    var cx1 = box.container.owner.x + box.x;
    var cy1 = box.container.owner.y + box.y;
    var cx2 = cx1 + box.width;
    var cy2 = cy1 + box.height;

    return CollisionUtil.checkCollision(tx1, ty1, tx2, ty2, cx1, cy1, cx2, cy2);
};

CollisionBox.prototype.draw = function(gfx)
{
    //gfx.fillRect(this.container.owner.x + this.x, this.container.owner.y + this.y, this.width, this.height, "#F00");
    //gfx.drawRect(this.container.owner.x + this.x, this.container.owner.y + this.y, this.width, this.height, "#000", 1);
};
/**
 * Created by Jelle on 5/7/2014.
 */

CollisionContainer = function()
{
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;

    this.boxes = [];

    this.isColliding = false;

    this.collidingWith = [];
};

CollisionContainer.prototype.addBox = function(x, y, width, height)
{
    var box = new CollisionBox(x, y, width, height);
    box.container = this;
    this.boxes.push(box);
};

CollisionContainer.prototype.initialize = function()
{
    var px1 = undefined;
    var py1 = undefined;
    var px2 = undefined;
    var py2 = undefined;

    for(var i = 0; i < this.boxes.length; i++)
    {
        var box = this.boxes[i];
        var cx1 = box.x;
        var cy1 = box.y;
        var cx2 = box.x + box.width;
        var cy2 = box.y + box.height;

        if(cx1 < px1 || px1 == undefined)
            px1 = cx1;
        if(cy1 < py1 || py1 == undefined)
            py1 = cy1;
        if(cx2 > px2 || px2 == undefined)
            px2 = cx2;
        if(cy2 > py2 || py2 == undefined)
            py2 = cy2;
    }

    if(px1 != undefined){this.x = px1;}else{this.x = 0;}
    if(py1 != undefined){this.y = py1;}else{this.y = 0;}
    if(px2 != undefined){this.width = px2 - px1;}else{this.width = 0;}
    if(py2 != undefined){this.height = py2 - py1;}else{this.height = 0;}
};

CollisionContainer.prototype.isCollidingWith = function(checkContainer)
{
    var tx1 = this.owner.x + this.x;
    var ty1 = this.owner.y + this.y;
    var tx2 = tx1 + this.width;
    var ty2 = ty1 + this.height;

    var cx1 = checkContainer.owner.x + checkContainer.x;
    var cy1 = checkContainer.owner.y + checkContainer.y;
    var cx2 = cx1 + checkContainer.width;
    var cy2 = cy1 + checkContainer.height;

    return CollisionUtil.checkCollision(tx1, ty1, tx2, ty2, cx1, cy1, cx2, cy2);
};

CollisionContainer.prototype.tick = function(obstacles)
{
    for(var i = 0; i < obstacles.length; i++)
    {
        if(obstacles[i].collisionContainer.isCollidingWith(this))
        {
            if(obstacles[i].collisionContainer.boxes.length == 1)
            {
                obstacles[i].onPlayerCollision(this.owner);
            }
            else
            {
                var boxes = obstacles[i].collisionContainer.boxes;
                for(var j = 0; j < boxes.length; j++)
                {
                    if(boxes[j].isCollidingWith(this.boxes[0]))
                    {
                        obstacles[i].onPlayerCollision(this.owner);
                        break;
                    }
                }
            }
        }
    }
};

CollisionContainer.prototype.draw = function(gfx)
{
    if(this.boxes.length > 0)
    {
        for(var i = 0; i < this.boxes.length; i++)
        {
            //this.boxes[i].draw(gfx);
        }
    }

    if(this.isColliding == true)
    {
        this.isColliding = false;
        //gfx.drawRect(this.owner.x + this.x, this.owner.y + this.y, this.width, this.height, "#00F", 2);
    }
    else
    {
        //gfx.drawRect(this.owner.x + this.x, this.owner.y + this.y, this.width, this.height, "#FF0", 2);
    }
};
/**
 * Created by Jelle on 5/9/2014.
 */

CollisionUtil = function(){};

CollisionUtil.checkCollision = function(tx1, ty1, tx2, ty2, cx1, cy1, cx2, cy2)
{
    // left
    if (tx2 > cx1 && tx1 < cx1)
    {
        if ((ty1 < cy2 && ty2 > cy1) || (ty2 > cy1 && ty1 < cy2))
        {
            return true;
        }
    }

    // up
    if (ty1 < cy2 && ty2 > cy2)
    {
        if ((tx1 < cx2 && tx2 > cx1) || (tx2 > cx1 && tx1 < cx2))
        {
            return true;
        }
    }

    // right
    if (tx1 < cx2 && tx2 > cx2)
    {
        if ((ty1 < cy2 && ty2 > cy1) || (ty2 > cy1 && ty1 < cy2))
        {
            return true;
        }
    }

    // down
    if (ty2 > cy1 && ty1 < cy1)
    {
        if ((tx1 < cx2 && tx2 > cx1) || (tx2 > cx1 && tx1 < cx2))
        {
            return true;
        }
    }

    return false;
};
/**
 * Created by Jelle on 5/7/2014.
 */

BigObstacle = function()
{
    this.remove = false;

    this.texture = Files.PIC_GAME_OBJECT_OBSTACLEWALLNORMAL.obj;

    this.width = this.texture.width;
    this.height = this.texture.height * 2;

    this.x = Align.width;
    this.y = (Align.height / 2) - (this.height + 20);

    this.collisionContainer = new CollisionContainer();
    this.collisionContainer.addBox(0, 0, this.width, this.height);

    this.collisionContainer.owner = this;
    this.collisionContainer.initialize();
};

BigObstacle.prototype.onPlayerCollision = function(player)
{
    this.collisionContainer.isColliding = true;
    player.onCollision();
};

BigObstacle.prototype.tick = function()
{
    this.x -= 10;
    if(this.x < 0 - this.width)
    {
        this.remove = true;
    }
};

BigObstacle.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.texture, this.x, this.y, this.width, this.height);

    this.collisionContainer.draw(gfx, this.x, this.y);
};
/**
 * Created by Jelle on 5/7/2014.
 */

Obstacle = function()
{
    this.remove = false;

    this.texture = Files.PIC_GAME_OBJECT_OBSTACLEWALLNORMAL.obj;

    this.width = this.texture.width;
    this.height = this.texture.height;

    this.x = Align.width;
    this.y = (Align.height / 2) - (this.height + 20);

    this.collisionContainer = new CollisionContainer();
    this.collisionContainer.addBox(0, 0, this.width, this.height);

    this.collisionContainer.owner = this;
    this.collisionContainer.initialize();
};

Obstacle.prototype.onPlayerCollision = function(player)
{
    this.collisionContainer.isColliding = true;
    player.onCollision();
};

Obstacle.prototype.tick = function()
{
    this.x -= 10;
    if(this.x < 0 - this.width)
    {
        this.remove = true;
    }
};

Obstacle.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.texture, this.x, this.y, this.width, this.height);

    this.collisionContainer.draw(gfx, this.x, this.y);
};
/**
 * Created by Jelle on 5/13/2014.
 */

BackgroundHandler = function(x)
{
    this.x = x * 400;

    this.layers = [];

    this.backgroundTexture = Files.PIC_GAME__BACKGROUND.obj;

    this.layers.push(new BackgroundLayer(Files.PIC_GAME__BACKGROUND_01, 1));
    this.layers.push(new BackgroundLayer(Files.PIC_GAME__BACKGROUND_02, 2));
    this.layers.push(new BackgroundLayer(Files.PIC_GAME__BACKGROUND_03, 3));

    for(var i = 0; i < this.layers.length; i++)
    {
        this.layers[i].x -= this.x;
    }

    this.ground = new Ground();
};

BackgroundHandler.prototype.tick = function()
{
    for(var i = 0; i < this.layers.length; i++)
    {
        this.layers[i].tick();
    }
};

BackgroundHandler.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.backgroundTexture, 0, 0, Align.width, 540);

    for(var i = 0; i < this.layers.length; i++)
    {
        this.layers[i].draw(gfx);
    }

    this.ground.draw(gfx);
};
/**
 * Created by Jelle on 5/13/2014.
 */

BackgroundLayer = function(textureObj, speed)
{
    this.texture = textureObj.obj;
    this.speed = speed;

    this.width = this.texture.width;

    this.x = 0;
};

BackgroundLayer.prototype.tick = function()
{
    this.x -= this.speed;
    this.x = this.x % this.width;
};

BackgroundLayer.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.texture, this.x, 0, this.width + 2, 540);
    gfx.drawTexture(this.texture, this.x + this.width, 0, this.width + 2, 540);
};
/**
 * Created by Jelle on 5/6/2014.
 */

GameHandler = function(item)
{
    this.item = item;

    SFX.setBackgroundSound(Files.SND_GAME_BACKGROUND);

    this.sharedSpawnOptions = new SharedSpawnOptions();

    this.world1 = new World(1);
    this.world2 = new World(-1);

    this.world1.gameHandler = this;
    this.world2.gameHandler = this;

    this.world1.otherWorld = this.world2;
    this.world2.otherWorld = this.world1;

    this.world1.initialize();
    this.world2.initialize();
};

GameHandler.prototype.tick = function()
{
    this.world1.tick();
    this.world2.tick();
};

GameHandler.prototype.draw = function(gfx)
{
    gfx.clear("#000");

    this.world1.draw(gfx);
    this.world2.draw(gfx);
};
/**
 * Created by Jelle on 5/13/2014.
 */

Ground = function()
{
    this.color = "#191919";
    this.width = Align.width;
    this.height = 20;
};

Ground.prototype.draw = function(gfx)
{
    gfx.fillRect(0, 540 - this.height, Align.width, this.height + 1, this.color);
};
/**
 * Created by Jelle on 5/7/2014.
 */

ObjectHandler = function(world)
{
    this.world = world;

    // obstacles
    this.obstacleSpawner = new ObstacleSpawner();
    this.obstacleSpawner.objectHandler = this;
    this.obstacles = [];

    // player
    this.player = new Player(this.world.dir);
    this.player.objectHandler = this;
};

ObjectHandler.prototype.initialize = function()
{
    this.obstacleSpawner.initialize();
    this.player.otherPlayer = this.world.otherWorld.objectHandler.player;
};

ObjectHandler.prototype.addObstacle = function(obj)
{
    this.obstacles.push(obj);
};

ObjectHandler.prototype.tick = function()
{
    this.obstacleSpawner.tick();

    for(var i = 0; i < this.obstacles.length; i++)
    {
        this.obstacles[i].tick();
        if(this.obstacles[i].remove == true)
        {
            this.obstacles.splice(i, 1);
            i -= 1;
        }
    }

    this.player.tick();
};

ObjectHandler.prototype.draw = function(gfx)
{
    for(var i = 0; i < this.obstacles.length; i++)
    {
        this.obstacles[i].draw(gfx);
    }

    this.player.draw(gfx);
};
/**
 * Created by Jelle on 5/7/2014.
 */

ObstacleSpawner = function()
{
    this.curTick = 300;
};

ObstacleSpawner.prototype.initialize = function()
{
    this.sharedSpawnOptions = this.objectHandler.world.gameHandler.sharedSpawnOptions;
};

ObstacleSpawner.prototype.spawn = function()
{
    this.curTick = 0;
    var obstacle = new Obstacle(this.objectHandler.world.dir);
    this.objectHandler.addObstacle(obstacle);
};

ObstacleSpawner.prototype.tick = function()
{
    this.curTick++;

    if(this.curTick > 300)
    {
        this.spawn();
    }
};
/**
 * Created by Jelle on 5/6/2014.
 */

Player = function()
{
    this.texture = Files.PIC_GAME_OBJECT_PLAYER.obj;

    this.width = this.texture.width;
    this.height = this.texture.height;

    this.collisionContainer = new CollisionContainer();
    this.collisionContainer.addBox(0, 0, this.width, this.height);

    this.collisionContainer.owner = this;
    this.collisionContainer.initialize();

    this.hasCollided = false;
    this.isImmuneFor = 0;

    this.x = (Align.width / 2) - (this.width / 2);
    this.y = (Align.height / 2) - ((this.collisionContainer.height + 20) + this.collisionContainer.y);
    this.groundy = this.y;

    this.gravity = 0.8;
    this.speedy = 0;
    this.shouldStomp = false;
    this.hasJumped = false;
};

Player.prototype.tryJump = function()
{
    if(this.hasCollided == false)
    {
        if(this.hasJumped == false)
        {
            this.speedy = -20;
            this.hasJumped = true;
            SFX.playSound(Files.SND_GAME_PLAYER_JUMP);
        }
        else
        {
            this.speedy = 50;
            this.shouldStomp = true;
        }
    }
};

Player.prototype.tryStomp = function()
{
    if(this.hasCollided == false && this.y == this.groundy)
    {
        this.speedy = -20;
    }
};

Player.prototype.onCollision = function()
{
    this.collisionContainer.isColliding = true;
    this.hasCollided = true;
    this.shouldStomp = false;

    this.isImmuneFor = 180;
    SFX.playSound(Files.SND_GAME_PLAYER_DEATH);
};

Player.prototype.tick = function()
{
    this.speedy += this.gravity;
    this.y += this.speedy;

    if(this.y >= this.groundy)
    {
        this.y = this.groundy;
        this.hasJumped = false;
        if(this.shouldStomp)
        {
            this.shouldStomp = false;
            this.otherPlayer.tryStomp();
            SFX.playSound(Files.SND_GAME_PLAYER_STOMP);
        }
    }

    if(this.isImmuneFor > 0)
    {
        this.isImmuneFor--;
        if(this.isImmuneFor == 0)
        {
            this.hasCollided = false;
        }
    }
    else
    {
        if(this.hasCollided == false)
        {
            this.collisionContainer.tick(this.objectHandler.obstacles);
        }
    }
};

Player.prototype.respawn = function()
{
    this.x = (Align.width / 2) - (this.width / 2);
    this.hasCollided = false;
};

Player.prototype.draw = function(gfx)
{
    if(this.isImmuneFor > 0)
    {
        gfx.drawTransparentTexture(this.texture, this.x, this.y, this.width, this.height, 0.3);
    }
    else
    {
        gfx.drawTexture(this.texture, this.x, this.y, this.width, this.height);
    }

    this.collisionContainer.draw(gfx);
};
/**
 * Created by Jelle on 5/9/2014.
 */

SharedSpawnOptions = function()
{

};
/**
 * Created by Jelle on 5/7/2014.
 */

World = function(dir)
{
    this.dir = dir;

    this.backgroundHandler = new BackgroundHandler((-(this.dir - 1)));

    this.buttons = [];

    var button = undefined;

    // Jump button
    button = new RotatableButton();
    button.alignx = Align.LEFT;
    button.aligny = Align.TOP;
    button.setTexture(Files.PIC_GAME_BUTTON_JUMP.obj);
    button.setSize(Files.PIC_GAME_BUTTON_JUMP.obj.width, Files.PIC_GAME_BUTTON_JUMP.obj.height);

    var screenPosX = -(Align.width / 2) * (dir - 1);
    var screenPosY = -(Align.height / 2) * (dir - 1);

    var objPosX = (button.width / 2) * (dir);
    var objPosY = (button.height / 2) * (dir);

    button.setPosition(screenPosX + objPosX, screenPosY + objPosY);

    button.rotation = (dir + 1) * 90;
    button.world = this;
    button.onClick = function(){this.world.otherWorld.objectHandler.player.tryJump();};
    this.buttons.push(button);

    // Back button
    button = new RotatableButton();
    button.alignx = Align.LEFT;
    button.aligny = Align.TOP;
    button.setTexture(Files.PIC_GAME_BUTTON_BACK.obj);
    button.setSize(Files.PIC_GAME_BUTTON_BACK.obj.width, Files.PIC_GAME_BUTTON_BACK.obj.height);

    var screenPosX = (Align.width / 2) * (dir + 1);
    var screenPosY = -(Align.height / 2) * (dir - 1);

    var objPosX = -(button.width / 2) * (dir);
    var objPosY = (button.height / 2) * (dir);

    button.setPosition(screenPosX + objPosX, screenPosY + objPosY);

    button.rotation = (dir + 1) * 90;
    button.world = this;
    button.onClick = function(){this.world.gameHandler.item.itemHandler.setGotoItem(ItemMainMenu)};
    this.buttons.push(button);

    this.objectHandler = new ObjectHandler(this);
};

World.prototype.initialize = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].item = this.gameHandler.item;
        this.buttons[i].initialize();
    }

    this.objectHandler.initialize();
};

World.prototype.tick = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].tick();
    }

    this.backgroundHandler.tick();

    this.objectHandler.tick();
};

World.prototype.draw = function(gfx)
{
    // prepare draw
    gfx.gfx.save();
    gfx.gfx.scale(1, this.dir);
    gfx.gfx.translate(0, (Align.height / 2) * (this.dir - 1));

    this.backgroundHandler.draw(gfx);
    this.objectHandler.draw(gfx);

    gfx.gfx.restore();

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].draw(gfx);
    }
};
JumpState = function(pWorld)
{
    this.world = pWorld;
    this.objectHandler = this.world.objectHandler;
    this.innerState = 0;
    this.done = false;
};

JumpState.prototype.nextInnerState = function()
{
    this.innerState++;
    console.log("Next inner state " + this.innerState);
};

JumpState.prototype.start = function()
{
    this.spawnBlock();
};

JumpState.prototype.handleJump = function()
{
    if(this.innerState >= 1){
        if(this.innerState == 1)
        {
            this.world.worldPaused = false;
            this.nextInnerState();
        }
        return true;
    } else {
        return false;
    }
};

JumpState.prototype.spawnBlock = function()
{
    this.world.objectHandler.obstacles = [];
    this.world.objectHandler.addObstacle(new Obstacle(this.world.dir));
};

JumpState.prototype.reset = function()
{
    this.innerState = 0;
    this.done = false;
    this.start();
};

JumpState.prototype.tick = function()
{
    var distToPlayer = this.world.currentObstacleFromPlayer();

    if(this.innerState == 0)
    {
        if(distToPlayer > 0 && distToPlayer < 200)
        {
            this.world.worldPaused = true;
            this.nextInnerState();
            // After the jump the innerState will be incremented to 2
        }
    }
    else if(this.innerState == 2)
    {
        if(distToPlayer < -400 && distToPlayer > -1000)
        {
            this.spawnBlock();
            this.nextInnerState();
        }
        else if(this.objectHandler.player.hasCollided)
        {
            this.objectHandler.player.isImmuneFor = 0;
            this.objectHandler.player.hasCollided = 0;
            this.objectHandler.obstacles = [];
            this.spawnBlock();
            this.innerState--;
        }
    }
    else if(this.innerState == 3)
    {
        if(distToPlayer < -400 && distToPlayer > -1000)
        {
            this.nextInnerState();
        }
        else if(this.objectHandler.player.hasCollided)
        {
            this.objectHandler.player.isImmuneFor = 0;
            this.objectHandler.player.hasCollided = 0;
            this.objectHandler.obstacles = [];
            this.spawnBlock();
        }
    }
    else if(this.innerState == 4)
    {
        this.done = true;
    }

    // Players aren't allowed to jump
    this.objectHandler.player.shouldStomp = false;
};

JumpState.prototype.draw = function(gfx)
{
    if(this.done == true)
    {
        this.world.drawString(gfx, "Goedzo! Wacht nu op de andere speler!");
    }
    else if(this.innerState == 0)
    {
        this.world.drawString(gfx, "Wacht tot het obstakel dicht bij is");
    }
    else if(this.innerState == 1)
    {
        this.world.drawString(gfx, "Druk op springen om er over heen te komen");
    }
    else if(this.innerState == 3)
    {
        this.world.drawString(gfx, "Probeer het nu zonder hulp");
    }
};/**
 * Created by Yorick on 5/9/2014.
 */

TutorialHandler = function(item)
{
    this.item = item;

    this.world1 = new TutorialWorld(1, this);
    this.world2 = new TutorialWorld(-1, this);

    this.world1.gameHandler = this;
    this.world2.gameHandler = this;

    this.world1.otherWorld = this.world2;
    this.world2.otherWorld = this.world1;

    this.world1.jumpDone = true;
    this.world2.jumpDone = true;

    this.world1.initialize();
    this.world2.initialize();

    // For the stomp jump
    this.stompTutStarted = false;
    this.world1Learning = true;
    this.world1Step = 0;
    this.world2Step = 0;

    this.tutorialDone = false;
    this.doneCounter = 0;
};

TutorialHandler.prototype.pauseWorld = function()
{

};

TutorialHandler.prototype.tryNextState = function()
{
    // 1.) Spawn small block
    // 2.) Spawn big block
    // 3.) Start a game

    if(this.world1.jumpDoing == true && this.world2.jumpDoing == true && this.world1.jumpDone == true && this.world2.jumpDone == true)
    {
        // state++
        this.world1.jumpDoing = false;
        this.world2.jumpDoing = false;

        // Reset all the obstacles. To prevent weird bugs
        if(!this.stompTutStarted)
        {
            this.stompTutStarted = true;
            this.world1.objectHandler.obstacles = [];
            this.world2.objectHandler.obstacles = [];
        }
    }
};

TutorialHandler.prototype.handleJump = function(worldDir)
{
    if(this.world1Learning)
    {
        if(worldDir == 1)
        {
            if(this.world1Step == 4 && this.world2Step == 3)
            {
                this.world2.worldPaused = false;
                this.world1.worldPaused = false;
                this.world1Step++;
                return true;
            }

            return false;
        }
        else if(worldDir == -1)
        {
            if(this.world2Step == 1)
            {
                this.world1.worldPaused = false;
                return true;
            }
            else if(this.world2Step == 2)
            {
                this.world2.worldPaused = false;
                this.world1.worldPaused = false;
                this.world1Step++;
                return true;
            }
            return false;
        }
    }
    else
    {
        if(worldDir == -1)
        {
            if(this.world2Step == 4 && this.world1Step == 3)
            {
                this.world2.worldPaused = false;
                this.world1.worldPaused = false;
                this.world2Step++;
                return true;
            }

            return false;
        }
        else if(worldDir == 1)
        {
            if(this.world1Step == 1)
            {
                this.world2.worldPaused = false;
                return true;
            }
            else if(this.world1Step == 2)
            {
                this.world2.worldPaused = false;
                this.world1.worldPaused = false;
                return true;
            }
            return false;
        }
    }
};

TutorialHandler.prototype.tick = function()
{
    this.world1.tick();
    this.world2.tick();

    this.tryNextState();

    if(this.tutorialDone)
    {
        this.doneCounter++;

        if(this.doneCounter > 50)
        {
            this.item.itemHandler.setGotoItem(ItemGame);
        }
    }
    else
    {
        if(this.world1.jumpDone && this.world2.jumpDone)
        {
            // Stomp tutorial hier
            if(this.world1Learning)
            {
                if(this.world1Step == 0)
                {
                    this.world1.objectHandler.addObstacle(new BigObstacle(this.world1.dir));
                    this.world1Step = 3;
                }

                if(this.world2Step == 0)
                {
                    if(this.world1.objectHandler.obstacles[0] != undefined)
                    {
                        var distance = this.world1.currentObstacleFromPlayer();
                        if(distance > 0 && distance < 450)
                        {
                            this.world1.worldPaused = true;
                            //this.world2.worldPaused = false;
                            this.world2Step++;
                        }
                    }
                }
                else if(this.world2Step == 1)
                {
                    var distance = this.world1.currentObstacleFromPlayer();
                    if(distance > 0 && distance < 300)
                    {
                        this.world2.worldPaused = true;
                        this.world1.worldPaused = true;
                        this.world2Step++;
                    }
                }
                else if(this.world2Step == 2)
                {
                    var distance = this.world1.currentObstacleFromPlayer();
                    if(distance > 0 && distance < 200)
                    {
                        this.world2.worldPaused = true;
                        this.world1.worldPaused = true;
                        this.world2Step++;
                    }
                }

                if(this.world1Step == 5 && this.world2Step == 3)
                {
                    var distance = this.world1.currentObstacleFromPlayer();
                    if(distance < -100)
                    {
                        this.world1Learning = false;
                        this.world1Step = 0;
                        this.world2Step = 0;
                    }
                }
            }
            else // Switch world1 with world2
            {
                if(this.world2Step == 0)
                {
                    this.world2.objectHandler.addObstacle(new BigObstacle(this.world2.dir));
                    this.world2Step = 4;
                }


                if(this.world1Step == 0)
                {
                    if(this.world2.objectHandler.obstacles[0] != undefined)
                    {
                        var distance = this.world2.currentObstacleFromPlayer();
                        if(distance > 0 && distance < 450)
                        {
                            this.world2.worldPaused = true;
                            //this.world2.worldPaused = false;
                            this.world1.canPlayerJump = true;
                            this.world1Step++;
                        }
                    }
                }
                else if(this.world1Step == 1)
                {
                    var distance = this.world2.currentObstacleFromPlayer();
                    if(distance > 0 && distance < 300)
                    {
                        this.world2.worldPaused = true;
                        this.world1.worldPaused = true;
                        this.world1Step++;
                    }
                }
                else if(this.world1Step == 2)
                {
                    var distance = this.world2.currentObstacleFromPlayer();
                    if(distance > 0 && distance < 200)
                    {
                        this.world2.worldPaused = true;
                        this.world1.worldPaused = true;
                        this.world1Step++;
                    }
                }

                if(this.world1Step == 3 && this.world2Step == 5)
                {
                    var distance = this.world2.currentObstacleFromPlayer();
                    console.log(distance);
                    if(distance < -100)
                    {
                        this.tutorialDone = true;
                    }
                }
            }
        }
    }
};

TutorialHandler.prototype.draw = function(gfx)
{
    gfx.clear("#000");

    this.world1.draw(gfx);
    this.world2.draw(gfx);

    if(this.tutorialDone)
    {
        this.world1.drawString(gfx, "Goed gedaan je bent klaar voor het echte werk!");
        this.world2.drawString(gfx, "Goed gedaan je bent klaar voor het echte werk!");
    }
    else if(this.world1.jumpDone == true && this.world2.jumpDone == true)
    {
        if(this.world1Learning)
        {
            switch(this.world1Step)
            {
                case 1:
                    this.world1.drawString(gfx, "Sommige obstakels zijn te groot om alleen over heen te komen ");
                break;
                case 4:
                    this.world1.drawString(gfx, "Spring nu om extra hoog te komen ");
                break;
                default:
                    this.world1.drawString(gfx, "De andere speler is bezig met zijn deel ");
                    break;
            }

            switch(this.world2Step)
            {
                case 0:
                    this.world2.drawString(gfx, "Sommige obstakels zijn te groot om alleen over heen te komen ");
                break;
                case 1:
                    this.world2.drawString(gfx, "Spring ");
                break;
                case 2:
                    this.world2.drawString(gfx, "Als je nu nog eens op spring drukt stomp je de andere omhoog ");
                break;
                case 3:
                    this.world2.drawString(gfx, "De andere speler is bezig met zijn deel ");
                break;
                default:
                    this.world2.drawString(gfx, "De andere speler is bezig met zijn deel ");
                    break;
            }
        }
        else
        {
            switch(this.world2Step)
            {
                case 1:
                    this.world2.drawString(gfx, "Sommige obstakels zijn te groot om alleen over heen te komen");
                break;
                case 4:
                    this.world2.drawString(gfx, "Spring nu om extra hoog te komen");
                break;
                default:
                    this.world2.drawString(gfx, "Wacht op andere speler");
                    break;
            }

            switch(this.world1Step)
            {
                case 0:
                    this.world1.drawString(gfx, "Sommige obstakels zijn te groot om alleen over heen te komen");
                break;
                case 1:
                    this.world1.drawString(gfx, "Spring");
                break;
                case 2:
                    this.world1.drawString(gfx, "Als je nu nog eens op spring drukt stomp je de andere omhoog");
                break;
                case 3:
                    this.world1.drawString(gfx, "Wacht op de andere speler");
                break;
                default:
                    this.world1.drawString(gfx, "Wacht op andere speler");
                    break;
            }
        }
    }
};
/**
 * Created by Jelle on 5/7/2014.
 */

TutorialObjectHandler = function(world)
{
    this.world = world;

    // obstacles
    this.obstacles = [];

    // player
    this.player = new Player(this.world.dir);
    this.player.objectHandler = this;
};

TutorialObjectHandler.prototype.initialize = function()
{
    this.player.otherPlayer = this.world.otherWorld.objectHandler.player;
};

TutorialObjectHandler.prototype.addObstacle = function(obj)
{
    this.obstacles.push(obj);
};

TutorialObjectHandler.prototype.tick = function()
{
    for(var i = 0; i < this.obstacles.length; i++)
    {
        this.obstacles[i].tick();
        if(this.obstacles[i].remove == true)
        {
            this.obstacles.splice(i, 1);
            i -= 1;
        }
    }
    this.player.tick();
};

TutorialObjectHandler.prototype.draw = function(gfx)
{
    for(var i = 0; i < this.obstacles.length; i++)
    {
        this.obstacles[i].draw(gfx);
    }

    this.player.draw(gfx);
};
/**
 * Created by Yorick on 5/9/2014.
 */

TutorialWorld = function(dir, tutorialHandler)
{
    this.dir = dir;

    this.backgroundHandler = new BackgroundHandler((-(this.dir - 1)));

    this.buttons = [];

    var button = undefined;

    this.jumpDone = false;
    this.jumpDoing = true;
    this.canPlayerJump = false;
    this.handler = tutorialHandler;

    // Jump button
    button = new RotatableButton();
    button.alignx = Align.LEFT;
    button.aligny = Align.TOP;
    button.setTexture(Files.PIC_GAME_BUTTON_JUMP.obj);
    button.setSize(Files.PIC_GAME_BUTTON_JUMP.obj.width, Files.PIC_GAME_BUTTON_JUMP.obj.height);

    var screenPosX = -(Align.width / 2) * (dir - 1);
    var screenPosY = -(Align.height / 2) * (dir - 1);

    var objPosX = (button.width / 2) * (dir);
    var objPosY = (button.height / 2) * (dir);

    button.setPosition(screenPosX + objPosX, screenPosY + objPosY);

    button.rotation = (dir + 1) * 90;
    button.world = this;
    button.onClick = function(){if(this.world.otherWorld.continueJump()){ this.world.otherWorld.objectHandler.player.tryJump();}};
    this.buttons.push(button);

    // Back button
    button = new RotatableButton();
    button.alignx = Align.LEFT;
    button.aligny = Align.TOP;
    button.setTexture(Files.PIC_GAME_BUTTON_BACK.obj);
    button.setSize(Files.PIC_GAME_BUTTON_BACK.obj.width, Files.PIC_GAME_BUTTON_BACK.obj.height);

    var screenPosX = (Align.width / 2) * (dir + 1);
    var screenPosY = -(Align.height / 2) * (dir - 1);

    var objPosX = -(button.width / 2) * (dir);
    var objPosY = (button.height / 2) * (dir);

    button.setPosition(screenPosX + objPosX, screenPosY + objPosY);

    button.rotation = (dir + 1) * 90;
    button.world = this;
    button.onClick = function(){this.world.gameHandler.item.itemHandler.setGotoItem(ItemMainMenu)};
    this.buttons.push(button);

    this.objectHandler = new TutorialObjectHandler(this);
    this.worldPaused = false;
};

TutorialWorld.prototype.initialize = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].item = this.gameHandler.item;
        this.buttons[i].initialize();
    }

    this.objectHandler.initialize();

    this.jumpState = new JumpState(this);
    if(!this.jumpDone)
    {
        this.jumpState.start();
    }
    else
    {
        this.jumpState.done = true
    }
};

TutorialWorld.prototype.currentObstacleFromPlayer = function()
{
    if(this.objectHandler.obstacles[0] === undefined)
    {
        return -77777;
    }

    return this.objectHandler.obstacles[0].x - this.objectHandler.player.x;
};

TutorialWorld.prototype.continueJump = function()
{
    if(this.jumpDoing)
    {
        return this.jumpState.handleJump();
    }

    return this.handler.handleJump(this.dir);
};

TutorialWorld.prototype.tick = function()
{
    this.jumpDone = this.jumpState.done;

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].tick();
    }

    if(this.jumpDoing){
        this.jumpState.tick();
    }

    if(!this.worldPaused){
        this.backgroundHandler.tick();
        this.objectHandler.tick();
    }
};

TutorialWorld.prototype.TouchDownInWorld = function()
{
    if(this.gameHandler.item.itemHandler.windowHandler.isMouseDown())
    {
        var mousesdown = this.gameHandler.item.itemHandler.windowHandler.getMousesDown();
        for(var i = 0; i < mousesdown.length; i++)
        {
            if(mousesdown[i].ticksAlive == 1)
            {
                if(this.dir == -1 && mousesdown[i].y > Align.height / 2)
                {
                    //console.log("BOTTOM SCREEN!" + mousesdown[i].y);
                    return true;
                }
                else if(this.dir == 1 && mousesdown[i].y < Align.height / 2)
                {
                    //console.log("TOP SCREEN!" + mousesdown[i].y);
                    return true;
                }
            }
        }
    }
    return false;
};

TutorialWorld.prototype.draw = function(gfx)
{
    // prepare draw
    gfx.gfx.save();
    gfx.gfx.scale(1, this.dir);
    gfx.gfx.translate(0, (Align.height / 2) * (this.dir - 1));

    this.backgroundHandler.draw(gfx);

    this.objectHandler.draw(gfx);

    if(this.jumpDoing){
        this.jumpState.draw(gfx);
    }

    gfx.gfx.restore();

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].draw(gfx);
    }
};

TutorialWorld.prototype.drawString = function(gfx, text)
{
    gfx.drawCenteredString(text, Align.width / 2, 200, "#FFF", "20pt Arial");
};
/**
 * Created by Jelle on 5/6/2014.
 */

GameHandler = function(item)
{
    this.item = item;

    this.sharedSpawnOptions = new SharedSpawnOptions();

    this.world1 = new World(1);
    this.world2 = new World(-1);

    this.world1.gameHandler = this;
    this.world2.gameHandler = this;

    this.world1.otherWorld = this.world2;
    this.world2.otherWorld = this.world1;

    this.world1.initialize();
    this.world2.initialize();
};

GameHandler.prototype.tick = function()
{
    this.world1.tick();
    this.world2.tick();
};

GameHandler.prototype.draw = function(gfx)
{
    gfx.clear("#000");

    this.world1.draw(gfx);
    this.world2.draw(gfx);
};
/**
 * Created by Jelle on 5/6/2014.
 */

ItemGame = function()
{
    this.gameHandler = new GameHandler(this);
};

ItemGame.prototype.initialize = function()
{
};

ItemGame.prototype.activate = function()
{
};

ItemGame.prototype.deActivate = function()
{
};

ItemGame.prototype.tick = function()
{
    this.gameHandler.tick();
};

ItemGame.prototype.draw = function(gfx)
{
    this.gameHandler.draw(gfx);
};
/**
 * Created by Yorick on 5/6/2014.
 */

ItemTutorial = function()
{
    this.tutHandler = new TutorialHandler(this);
};

ItemTutorial.prototype.initialize = function()
{
};

ItemTutorial.prototype.activate = function()
{
};

ItemTutorial.prototype.deActivate = function()
{
};

ItemTutorial.prototype.tick = function()
{
    this.tutHandler.tick();
};

ItemTutorial.prototype.draw = function(gfx)
{
    this.tutHandler.draw(gfx);
    //gfx.clear('#000000');
    //gfx.fillRect(10, 10, 100, 100, "#FF0000");
};
/**
 * Created by Jelle on 5/7/2014.
 */

ItemCreditsMenu = function()
{
    this.backgroundTexture = Files.PIC_MENU_BACKGROUND.obj;

    this.lastMouseX = 0;
    this.lastMouseY = 0;

    this.backButton = new Button();
    this.backButton.alignx = Align.CENTER;
    this.backButton.aligny = Align.CENTER;
    this.backButton.setTexture(Files.PIC_MENU_BUTTON_BACK.obj);
    this.backButton.setPosition(0, 0);
    this.backButton.setSize(Files.PIC_MENU_BUTTON_BACK.obj.width, Files.PIC_MENU_BUTTON_BACK.obj.height);
    this.backButton.onClick = function(){this.item.itemHandler.setGotoItem(ItemMainMenu);};
};

ItemCreditsMenu.prototype.initialize = function()
{
    this.backButton.item = this;
    this.backButton.initialize();
};

ItemCreditsMenu.prototype.activate = function()
{
};

ItemCreditsMenu.prototype.deActivate = function()
{
};

ItemCreditsMenu.prototype.tick = function()
{
    this.backButton.tick();
};

ItemCreditsMenu.prototype.draw = function(gfx)
{
    gfx.clear("black");
    //gfx.drawTexture(this.backgroundTexture, 0, 0, Align.width, Align.height);

    this.backButton.draw(gfx);
};
/**
 * Created by Jelle on 4/27/2014.
 */

ItemMainMenu = function()
{
    this.backgroundTexture = Files.PIC_MENU_BACKGROUND.obj;

    this.buttons = [];

    var button = undefined;

    // Play button
    button = new Button();
    button.alignx = Align.CENTER;
    button.aligny = Align.CENTER;
    button.setTexture(Files.PIC_MENU_BUTTON_PLAY.obj);
    button.setPosition(0, -350);
    button.setSize(Files.PIC_MENU_BUTTON_PLAY.obj.width - 50, Files.PIC_MENU_BUTTON_PLAY.obj.height - 50);
    button.onClick = function(){this.item.itemHandler.setGotoItem(ItemTutorial);};
    this.buttons.push(button);

    // Options button
    button = new Button();
    button.alignx = Align.CENTER;
    button.aligny = Align.CENTER;
    button.setTexture(Files.PIC_MENU_BUTTON_OPTIONS.obj);
    button.setPosition(0, 0);
    button.setSize(Files.PIC_MENU_BUTTON_OPTIONS.obj.width - 50, Files.PIC_MENU_BUTTON_OPTIONS.obj.height - 50);
    button.onClick = function(){this.item.itemHandler.setGotoItem(ItemOptionsMenu);};
    this.buttons.push(button);

    // Credits button
    button = new Button();
    button.alignx = Align.CENTER;
    button.aligny = Align.CENTER;
    button.setTexture(Files.PIC_MENU_BUTTON_CREDITS.obj);
    button.setPosition(0, 350);
    button.setSize(Files.PIC_MENU_BUTTON_CREDITS.obj.width - 50, Files.PIC_MENU_BUTTON_CREDITS.obj.height - 50);
    button.onClick = function(){this.item.itemHandler.setGotoItem(ItemCreditsMenu);};
    this.buttons.push(button);

    SFX.setBackgroundSound(Files.SND_MENU_BACKGROUND);
};

ItemMainMenu.prototype.initialize = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].item = this;
        this.buttons[i].initialize();
    }
};

ItemMainMenu.prototype.activate = function()
{

};

ItemMainMenu.prototype.deActivate = function()
{

};

ItemMainMenu.prototype.tick = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].tick();
    }
};

ItemMainMenu.prototype.draw = function(gfx)
{
    gfx.clear("black");
    gfx.drawTexture(this.backgroundTexture, 0, 0, Align.width, Align.height);

    var mouses = this.itemHandler.windowHandler.getMousesDown();
    for(var i = 0; i < mouses.length; i++)
    {
        gfx.fillRect(mouses[i].x - 10, mouses[i].y - 10, 20, 20, "yellow");
    }

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].draw(gfx);
    }

    gfx.drawString("Navigator: " + navigator.isCocoonJS, 10, 40, "#FF0", "30px Arial");
};
/**
 * Created by Jelle on 5/7/2014.
 */

ItemOptionsMenu = function()
{
    this.buttons = [];

    var button = undefined;

    // Back button
    button = new Button();
    button.alignx = Align.CENTER;
    button.aligny = Align.CENTER;
    button.setTexture(Files.PIC_MENU_BUTTON_BACK.obj);
    button.setPosition(0, 350);
    button.setSize(Files.PIC_MENU_BUTTON_BACK.obj.width - 50, Files.PIC_MENU_BUTTON_BACK.obj.height - 50);
    button.onClick = function(){this.item.itemHandler.setGotoItem(ItemMainMenu);};
    this.buttons.push(button);
};

ItemOptionsMenu.prototype.initialize = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].item = this;
        this.buttons[i].initialize();
    }
};

ItemOptionsMenu.prototype.activate = function()
{
};

ItemOptionsMenu.prototype.deActivate = function()
{
};

ItemOptionsMenu.prototype.tick = function()
{
    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].tick();
    }
};

ItemOptionsMenu.prototype.draw = function(gfx)
{
    gfx.clear("#000");

    for(var i = 0; i < this.buttons.length; i++)
    {
        this.buttons[i].draw(gfx);
    }
};
/**
 * Created by Jelle on 4/29/2014.
 */

ItemTestMenu = function()
{
    this.firstDraw = true;
};

ItemTestMenu.prototype.initialize = function()
{
};

ItemTestMenu.prototype.activate = function()
{
};

ItemTestMenu.prototype.deActivate = function()
{
};

ItemTestMenu.prototype.tick = function()
{
};

ItemTestMenu.prototype.draw = function(gfx)
{
    if(this.firstDraw == true)
    {
        this.firstDraw = false;
        gfx.clear("#FFF");
    }

    if(this.itemHandler.windowHandler.isMouseDown())
    {
        var mousesdown = this.itemHandler.windowHandler.getMousesDown();
        for (var i = 0; i < mousesdown.length; i++)
        {
            if(mousesdown[i].lastX != mousesdown[i].x || mousesdown[i].lastY != mousesdown[i].y)
            {
                gfx.drawLine(mousesdown[i].lastX, mousesdown[i].lastY, mousesdown[i].x - mousesdown[i].lastX, mousesdown[i].y - mousesdown[i].lastY, mousesdown[i].color, 10);
            }
        }
    }
};
/**
 * Created by Jelle on 4/26/2014.
 */

ItemInitialize = function(){};

ItemInitialize.prototype.initialize = function()
{
    this.loader = new Loader(Files.prefiles);
    this.loader.start();
};

ItemInitialize.prototype.activate = function()
{

};

ItemInitialize.prototype.deActivate = function()
{

};

ItemInitialize.prototype.tick = function()
{
    if(this.loader.done == true)
    {
        this.itemHandler.setGotoItem(ItemLoader);
    }
};

ItemInitialize.prototype.draw = function(gfx)
{
    gfx.clear("black");
};
/**
 * Created by Jelle on 4/26/2014.
 */

ItemLoader = function()
{
    this.backgroundTexture = Files.PIC_LOADER_BACKGROUND.obj;

    this.loader = new Loader(Files.files);
    this.loader.start();
};

ItemLoader.prototype.initialize = function()
{

};

ItemLoader.prototype.activate = function()
{

};

ItemLoader.prototype.deActivate = function()
{

};

ItemLoader.prototype.tick = function()
{
    if(this.loader.done == true)
    {
        this.itemHandler.setGotoItem(ItemMainMenu);
    }
};

ItemLoader.prototype.draw = function(gfx)
{
    gfx.drawTexture(this.backgroundTexture, 0, 0, Align.width, Align.height);


};
/**
 * Created by Jelle on 4/25/2014.
 */

FileComponent = function()
{
    this.path = "";
    this.obj = null;
};

Files = function(){};
Files.prefiles = [];
Files.files = [];
Files.addPreFile = function(path)
{
    if(path != undefined && path != "")
    {
        var component = new FileComponent();
        component.path = path;

        Files.prefiles.push(component);
        return component;
    }
};

Files.addFile = function(path)
{
    if(path != undefined && path != "")
    {
        var component = new FileComponent();
        component.path = path;

        Files.files.push(component);
        return component;
    }
};

//////// ----- PreFile list ----- ////////
Files.PIC_LOADER_BACKGROUND = Files.addPreFile("PreAssets/Background.jpg");
Files.PIC_LOADER_LOADINGBAR = Files.addPreFile("PreAssets/LoadingBar.png");
Files.PIC_LOADER_LOADINGBAROUTLINE = Files.addPreFile("PreAssets/LoadingBarOutline.png");

//////// ----- File list ----- ////////
Files.PIC_MENU_BACKGROUND = Files.addFile("Assets/Menu/Background.jpg");
Files.PIC_MENU_BUTTON_PLAY = Files.addFile("Assets/Menu/PlayButton.png");
Files.PIC_MENU_BUTTON_OPTIONS = Files.addFile("Assets/Menu/OptionsButton.png");
Files.PIC_MENU_BUTTON_CREDITS = Files.addFile("Assets/Menu/CreditsButton.png");
Files.PIC_MENU_BUTTON_BACK = Files.addFile("Assets/Menu/BackButton.png");

Files.SND_MENU_BACKGROUND = "Assets/Audio/Background_mid.ogg";

Files.PIC_GAME__BACKGROUND = Files.addFile("Assets/Game/Themes/Theme_01/bg_01.png");
Files.PIC_GAME__BACKGROUND_01 = Files.addFile("Assets/Game/Themes/Theme_01/bg_02.png");
Files.PIC_GAME__BACKGROUND_02 = Files.addFile("Assets/Game/Themes/Theme_01/bg_03.png");
Files.PIC_GAME__BACKGROUND_03 = Files.addFile("Assets/Game/Themes/Theme_01/bg_04.png");

Files.PIC_GAME_BUTTON_JUMP = Files.addFile("Assets/Game/JumpButton.png");
Files.PIC_GAME_BUTTON_BACK = Files.addFile("Assets/Game/BackButton.png");

Files.PIC_GAME_OBJECT_PLAYER = Files.addFile("Assets/Game/Objects/Player.png");
Files.PIC_GAME_OBJECT_OBSTACLEWALLNORMAL = Files.addFile("Assets/Game/Objects/ObstacleWallNormal.png");

Files.SND_GAME_BACKGROUND = "Assets/Audio/Background_mid.ogg";
Files.SND_GAME_PLAYER_JUMP = "Assets/Audio/Jump.ogg";
Files.SND_GAME_PLAYER_STOMP = "Assets/Audio/Stomp.ogg";
Files.SND_GAME_PLAYER_DEATH = "Assets/Audio/Death.ogg";
/**
 * Created by Jelle on 4/25/2014.
 */

// run main when the document is ready
window.onload = function(){new Main();};

Main = function()
{
    console.log("Starting...");
    Arguments.initialize();
    var mywindow = new WindowHandler();
};
